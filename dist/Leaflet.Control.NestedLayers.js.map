{"version":3,"sources":["Leaflet.Control.NestedLayers.js"],"names":["NestedLayersComponent","props","handleToggleSelected","layer","id","newHierarchy","state","hierarchy","getLayerByID","toggleSelected","setState","makeComponentFromLayer","componentChildren","children","length","map","makeLayerKey","toString","name","roots","rootLayers","components","i","push","Component","propTypes","instanceOf","isRequired","NestedLayerComponent","onToggleSelected","getSwatch","swatch","itemClassNames","leaf","enabled","disabled","selected","func","any","NestedLayers","element","options","Error","_options","followAncestorVisibility","propogateDeselectToChildren","followAncestorMutability","Object","assign","_component","_isAttached","attach","isAttached","render","component","unmountComponentAtNode","_hierarchy","val","_element"],"mappings":"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","file":"Leaflet.Control.NestedLayers.js","sourcesContent":["// import chalk from 'chalk';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport PropTypes from 'prop-types';\nimport LayerHierarchy from './Leaflet.LayerHierarchy';\nimport NestedLayer from './Leaflet.NestedLayer';\nimport classnames from 'classnames';\n\n/**\n * React component to represent a LayerHierarchy\n * @param {object} props The component's props.\n * @param {LayerHierarchy} props.hierarchy The LayerHierarchy the component displays.\n */\nexport class NestedLayersComponent extends React.Component {\n  /**\n   * @param {object} props The component's props.\n   * @param {LayerHierarchy} props.hierarchy The LayerHierarchy the component displays.\n   */\n  constructor(props) {\n    super(props);\n    this.state = {\n      hierarchy: this.props.hierarchy\n    }\n  }\n\n  /**\n   * Describes the React props object\n   * @type {Object}\n   */\n  static propTypes = {\n    hierarchy: PropTypes.instanceOf(LayerHierarchy).isRequired\n  };\n\n  /**\n   * Generates a unique key for rendering a layer in JSX\n   * @param  {NestedLayer} layer The layer to use data from\n   * @return {string}       A string unique to this layer\n   */\n  makeLayerKey(layer) {\n    return (layer.id.toString + layer.name);\n  }\n\n  /**\n   * Event handler to toggle a layer's selected state\n   * @param  {NestedLayer} layer The layer to toggle\n   */\n  handleToggleSelected = (layer) => {\n    const id = layer.id;\n    const newHierarchy = this.state.hierarchy;\n    newHierarchy.getLayerByID(id).toggleSelected();\n    this.setState({\n      hierarchy: newHierarchy\n    });\n  }\n\n  /**\n   * Recursively renders a NestedLayer using NestedLayerComponent. If the NestedLayer has\n   * children, use this function as it not only renders a single NestedLayer, but also the subtree\n   * of layers under the NestedLayer recursively.\n   * @param  {NestedLayer} layer The layer to represent with a React component\n   * @return {NestedLayerComponent}       A react component representing the given NestedLayer.\n   */\n  makeComponentFromLayer = (layer) => {\n    // recursive function\n    // 'leaf' is the base case\n    // property initializer syntax + arrow function keeps the scope of 'this' through recursive calls\n    let componentChildren;\n\n    // branch: this layer has children\n    if (layer.children.length > 0) {\n      // leaves = layer.children.map(this.makeComponentFromLayer)\n      componentChildren = (\n        <ul className=\"branch\">\n          {layer.children.map(this.makeComponentFromLayer)}\n        </ul>\n      );\n    }\n\n    return (\n      <NestedLayerComponent layer={layer} onToggleSelected={this.handleToggleSelected} key={this.makeLayerKey(layer)}>\n        {componentChildren}\n      </NestedLayerComponent>\n    );\n\n  }\n\n  /**\n   * Renders the component\n   * @return {Component} JSX\n   */\n  render() {\n    const roots = this.state.hierarchy.rootLayers;\n    let components = [];\n\n    for (let i = 0; i < roots.length; i++) {\n      components.push(this.makeComponentFromLayer(roots[i]));\n    }\n\n    return (\n      <div className=\"nested-layer-control-container\">\n        <h2>TOC CONTROL</h2>\n        <ul className=\"branch nested-layer-control\">\n          {components}\n        </ul>\n      </div>\n    );\n  }\n}\n\n/**\n * React Component to represent a single NestedLayer\n * @param {object} props Component properties\n * @param {NestedLayer} props.layer The layer to represent\n * @param {function} props.onToggleSelected The callback to change the layer's selected state\n */\nexport class NestedLayerComponent extends React.Component {\n  /**\n   * @param {object} props Component properties\n   * @param {NestedLayer} props.layer The layer to represent\n   * @param {function} props.onToggleSelected The callback to change the layer's selected state\n   */\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  /**\n   * Describes the React props object\n   * @type {Object}\n   */\n  static propTypes = {\n    layer: PropTypes.instanceOf(NestedLayer).isRequired,\n    onToggleSelected: PropTypes.func.isRequired,\n    children: PropTypes.any\n  };\n\n  /**\n   * Calls the toggle selected state handler passed by the parent to change the selected state of\n   * the layer\n   */\n  toggleSelected = () => {\n    // updates both the component state and the LayerHierarchy structure\n    this.props.onToggleSelected(this.props.layer);\n  }\n\n  /**\n   * Returns a data URL suitable for use in a the src of an <img /> that contains the base 64\n   * encoded layer swatch\n   * @return {string} data URL containing the swatch\n   */\n  getSwatch = () => {\n    return 'data:image/png;base64,' + this.props.layer.swatch;\n  }\n\n  /**\n   * Renders the component\n   * @return {Component} JSX\n   */\n  render() {\n    const itemClassNames = classnames({\n      leaf: true,\n      enabled: this.props.layer.enabled,\n      disabled: this.props.layer.disabled\n    });\n    return (\n      <li className={itemClassNames} >\n        <input type=\"checkbox\" checked={this.props.layer.selected} onChange={this.toggleSelected}/>\n        {this.props.layer.swatch.length > 0 &&\n          <img src={this.getSwatch()} className=\"swatch\" />\n        }\n        <span className=\"layer-name\">{this.props.layer.name}</span>\n\n        {this.props.children}\n      </li>\n    );\n  }\n}\n\n/**\n * Leaflet plugin to display a hierarchial version of {@link http://leafletjs.com/reference-1.1.0.html#control-layers L.Control.Layers}. Uses React to wrap the\n * NestedLayersComponent.\n * @param  {LayerHierarchy} hierarchy The hierarchy to display in the control\n * @param  {Element} element   The DOM element to bind the control to\n * @param  {object} options   Configuration options that dictate how the control should behave\n */\nexport default class NestedLayers {\n\n  /**\n   * Initialize the plugin and {@link #NestedLayers#attach attaches} to the DOM.\n   * @param  {LayerHierarchy} hierarchy The hierarchy to display in the control\n   * @param  {Element} element   The DOM element to bind the control to\n   * @param  {object} options   Configuration options that dictate how the control should behave\n   * @param  {boolean} [options.followAncestorVisibility=true] Deselecting any ancestor makes its\n   * children invisible (without changing their selected state)\n   * @param {boolean} [options.propogateDeselectToChildren=false] Deselecting a parent also deselects\n   * children (by changing their state)\n   * @param {boolean} [options.followAncestorMutability=true] Deselecting any ancestor disables its\n   * children (cannot change children's selected state)\n   */\n  constructor(hierarchy, element, options) {\n\n    if (typeof hierarchy == 'undefined') {\n      throw new Error('Missing hierarchy when creating NestedLayers control');\n    }\n    this.hierarchy = hierarchy;\n    if (typeof element == 'undefined') {\n      throw new Error('Missing DOM element when creating NestedLayers control');\n    }\n    this.element = element;\n\n    // default options\n    this._options = {\n      followAncestorVisibility: true,\n      propogateDeselectToChildren: false,\n      followAncestorMutability: true\n    };\n\n    // overwrite defaults with passed options\n    Object.assign(this._options, options);\n\n    this._component = <NestedLayersComponent hierarchy={this.hierarchy} />\n\n    this._isAttached = false;\n\n    // bind to the DOM\n    this.attach();\n  }\n\n  /**\n   * The underlying hierarchy of layers the plugin visually represents\n   * @type {LayerHierarchy}\n   */\n  get hierarchy() {\n    return this._hierarchy;\n  }\n  /**\n   * Shorthand accessor for the {@link #NestedLayers#hierarchy hierarchy} property\n   */\n  get h() {\n    return this.hierarchy;\n  }\n  set hierarchy(val) {\n    this._hierarchy = val;\n  }\n\n  /**\n   * The DOM element that the control attaches to\n   * @type {Element}\n   */\n  get element() {\n    return this._element;\n  }\n  /**\n   * Shorthand accessor for the {@link #NestedLayers#element element} property\n   */\n  get el() {\n    return this.element;\n  }\n  set element(val) {\n    this._element = val;\n  }\n\n  /**\n   * The React component under the hood\n   * @type {NestedLayersComponent}\n   */\n  get component() {\n    return this._component;\n  }\n\n  /**\n   * True if the plugin has attached itself to the DOM element\n   * @type {boolean}\n   */\n  get isAttached() {\n    return this._isAttached;\n  }\n  // no direct setting of 'isAttached' from outside the class\n  // the attach() and detach() methods handle this state\n\n  /**\n   * Configuration options\n   * @type {object}\n   */\n  get options() {\n    return this._options;\n  }\n\n  /**\n   * Bind to the DOM. Internally, it checks to see if it has already been attached, and if not,\n   * uses React to render the {@link #NestedLayers#component component} to the specified {@link\n   * #NestedLayers#element element}.\n   */\n  attach() {\n    if (!this.isAttached) {\n      ReactDOM.render(\n        this.component,\n        this.element\n      );\n    }\n    this._isAttached = true;\n  }\n\n  /**\n   * Unbind from the DOM. Releases the {@link #NestedLayers#element element} for reuse.\n   */\n  detach() {\n    if (this.isAttached) {\n      ReactDOM.unmountComponentAtNode(this.element);\n    }\n    this._isAttached = true;\n  }\n\n}\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}