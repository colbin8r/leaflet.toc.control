{"version":3,"sources":["Leaflet.LayerHierarchy.MapServerParser.js"],"names":["request","MapServerParser","url","map","options","_convertLayerNodeToNestedLayer","node","layerData","id","name","leafletLayerData","_makeLayerURL","data","scale","maxZoom","crs","zoom","maxScale","minZoom","minScale","layer","defaultVisibility","selected","Error","_url","_map","_defaults","swatch","hierarchyOptions","_options","defaults","join","_queryLayers","_queryLegend","layerRes","legendRes","ok","body","type","Headers","Accept","JSON","parse","text","hierarchy","layers","forEach","parent","parentLayer","undefined","addLayer","layerdataURL","APISuffixes","get","set","query","QueryParameters","end","legendURL","legend","baseURL","layerID","toString","f"],"mappings":"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","file":"Leaflet.LayerHierarchy.MapServerParser.js","sourcesContent":["import LayerHierarchy from './Leaflet.LayerHierarchy';\nimport NestedLayer from './Leaflet.NestedLayer';\n\nimport { defaultsDeep as defaults } from 'lodash';\n// superagent mimics the node 'request' library on the client side as an xhr library\nimport superagent from 'superagent';\nimport Promise from 'bluebird';\nimport superagentPromise from 'superagent-promise';\nconst request = superagentPromise(superagent, Promise);\nimport { FeatureLayerService } from 'esri-leaflet';\n\n/**\n * Parses the layer data served by an ArcGIS MapServer\n * @param {string} url A valid and reachable ArcGIS MapServer URL\n * @param {L.Map} map A Leaflet Map object, which will be passed to all\n * the layers in the resulting LayerHierarchy\n * @param {object} [options] An optional configuration object\n */\nexport default class MapServerParser {\n\n  static APISuffixes = {\n    layers: '/layers',\n    legend: '/legend'\n  };\n\n  static QueryParameters = {\n    f: 'json'\n  };\n\n  static Headers = {\n    Accept: 'application/json'\n  };\n\n  /**\n   * Initializes the parser with the given parameters\n   * @param {string} url     A valid and reachable ArcGIS MapServer URL\n   * @param {L.Map} map     A Leaflet Map object, which will be passed to all\n   * the layers in the resulting LayerHierarchy\n   * @param {object} [options] An optional configuration object\n   * @param {object} [options.data] The configuration options related to what data\n   * should be parsed from the MapServer to be included on NestedLayer objects\n   * @param {boolean} [options.data.scale=true] Include minZoom and maxZoom\n   * parameters on the NestedLayer\n   * @param {boolean} [options.data.defaultVisibility=true] Include the\n   * initial selected state of the NestedLayer\n   * @param {object} [options.hierarchyOptions={}] The configuration options\n   * the NestedHierarchy takes on instantiation\n   */\n  constructor(url, map, options) {\n    // ensure required parameters are present\n    if (typeof url == 'undefined') {\n      throw new Error('Missing URL when creating MapServerParser');\n    }\n    if (typeof map == 'undefined') {\n      throw new Error('Missing Leaflet map object when creating MapServerParser');\n    }\n\n    // save url\n    this._url = url;\n\n    // save map\n    this._map = map;\n\n    // set default options\n    this._defaults = {\n      data: {\n        scale: true,\n        defaultVisibility: true,\n        swatch: false\n      },\n      hierarchyOptions: {}\n    }\n\n    // merge options with defaults\n    this._options = {};\n    // https://lodash.com/docs/4.17.4#defaultsDeep\n    defaults(this._options, options, this.defaults);\n  }\n\n  /**\n   * MapServer URL\n   * @type {string}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Leaflet Map object\n   * @type {L.Map}\n   */\n  get map() {\n    return this._map;\n  }\n\n  /**\n   * Configuration options\n   * @type {object}\n   */\n  get options() {\n    return this._options;\n  }\n\n  /**\n   * Default configuration options\n   * @type {object}\n   */\n  get defaults() {\n    return this._defaults;\n  }\n\n  parse() {\n    // we have to wait for both xhr promises to resolve before we can begin processing\n    // note that Promise.join returns a promise that resolves to a LayerHierarchy\n    return Promise.join(this._queryLayers(), this._queryLegend(), (layerRes, legendRes) => {\n      // ensure we hit HTTP 2xx statuses\n      if (!layerRes.ok || !legendRes.ok) {\n        throw new Error('Bad request: HTTP status was not 2xx');\n      }\n\n      // parse the layerdata into JSON\n      let body = layerRes.body;\n      // ArcGIS does not properly set its Content-Type header\n      // so force JSON parsing if superagent did not parse automatically\n      if (layerRes.type !== MapServerParser.Headers.Accept) {\n        body = JSON.parse(layerRes.text);\n      }\n\n      // create the LayerHierarchy\n      var hierarchy = new LayerHierarchy(this.options.hierarchyOptions);\n\n      // move layers down as children of other layers\n      body.layers.forEach((node) => {\n        let layer = this._convertLayerNodeToNestedLayer(node)\n        let parent = (node.parentLayer !== null ? node.parentLayer.id : undefined);\n        // if this layer has no parent, addLayer(...) will add as a root layer\n        hierarchy.addLayer(layer, parent);\n      });\n\n      // resolve the promise with the resulting LayerHierarchy\n      // console.log(hierarchy);\n      return hierarchy;\n    });\n  }\n\n  /**\n   * Queries the layers endpoint of the MapServer for layer data.\n   * @return {Promise} Promise that resolves the request.\n   */\n  _queryLayers() {\n    // assemble layerdata url\n    const layerdataURL = this.url + MapServerParser.APISuffixes.layers;\n\n    // fetch layerdata as JSON\n    return request\n      .get(layerdataURL)\n      .set(MapServerParser.Headers)\n      .query(MapServerParser.QueryParameters)\n      .end();\n  }\n\n  _queryLegend() {\n    // assemble legend url\n    const legendURL = this.url + MapServerParser.APISuffixes.legend;\n\n    // fetch legend as JSON\n    return request\n      .get(legendURL)\n      .set(MapServerParser.Headers)\n      .query(MapServerParser.QueryParameters)\n      .end();\n  }\n\n  _convertLayerNodeToNestedLayer = (node) => {\n    let layerData = {\n      id: node.id,\n      name: node.name,\n      map: this.map\n    };\n    // Leaflet layer data\n    let leafletLayerData = {\n      url: MapServerParser._makeLayerURL(this.url, layerData.id)\n    };\n\n    // get scale/zoom data from layer node\n    if (this.options.data.scale) {\n      // converts scale factor from ArcGIS to Leaflet's zoom factor\n      // http://leafletjs.com/reference-1.1.0.html#crs-scale\n      leafletLayerData.maxZoom = this.map.options.crs.zoom(node.maxScale);\n      leafletLayerData.minZoom = this.map.options.crs.zoom(node.minScale);\n    }\n\n    // attach the Leaflet layer object to the NestedLayer's data\n    layerData.layer = new FeatureLayerService(leafletLayerData);\n\n    // use the provided NestedLayer factory to turn layerData into an owned NestedLayer\n    let layer = new NestedLayer(layerData);\n\n    // set the selected state = to the node's default visibility state\n    if (this.options.data.defaultVisibility) {\n      layer.selected = node.defaultVisibility;\n    }\n\n    // returns a NestedLayer object\n    return layer;\n  }\n\n  static _makeLayerURL(baseURL, layerID) {\n    if (typeof baseURL !== 'string') {\n      throw new Error('Base URL was undefined, null, or was not a string');\n    }\n    if (typeof layerID !== 'number') {\n      throw new Error('ID was undefined, null, or was not a number');\n    }\n\n    return baseURL + '/' + layerID.toString();\n  }\n\n}\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}