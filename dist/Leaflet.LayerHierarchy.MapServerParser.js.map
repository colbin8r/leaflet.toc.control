{"version":3,"sources":["Leaflet.LayerHierarchy.MapServerParser.js"],"names":["request","MapServerParser","url","map","options","_convertLayerNodeToNestedLayer","node","legend","nestedLayerData","id","name","trim","leafletLayerData","_makeLayerURL","data","scale","console","warn","maxZoom","Math","floor","crs","zoom","maxScale","minZoom","ceil","minScale","swatch","_findSwatchInLegend","layer","defaultVisibility","selected","Error","_url","_map","_defaults","hierarchyOptions","_options","defaults","join","_queryLayers","_queryLegend","layerRes","legendRes","ok","body","type","Headers","Accept","JSON","parse","text","layers","hierarchy","forEach","parent","parentLayer","undefined","addLayer","layerdataURL","APIEndpoints","get","set","query","QueryParameters","end","legendURL","layerID","length","i","layerId","imageData","baseURL","toString","f"],"mappings":"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","file":"Leaflet.LayerHierarchy.MapServerParser.js","sourcesContent":["import LayerHierarchy from './Leaflet.LayerHierarchy';\nimport NestedLayer from './Leaflet.NestedLayer';\n\nimport { defaultsDeep as defaults } from 'lodash';\n// superagent mimics the node 'request' library on the client side as an xhr library\nimport superagent from 'superagent';\nimport Promise from 'bluebird';\nimport superagentPromise from 'superagent-promise';\nconst request = superagentPromise(superagent, Promise);\nimport { FeatureLayer } from 'esri-leaflet';\n\n/**\n * Parses the layer data served by an ArcGIS MapServer\n * @param {string} url A valid and reachable ArcGIS MapServer URL\n * @param {L.Map} map A Leaflet Map object, which will be passed to all\n * the layers in the resulting LayerHierarchy\n * @param {object} [options] An optional configuration object\n */\nexport default class MapServerParser {\n\n  static APIEndpoints = {\n    layers: '/layers',\n    legend: '/legend'\n  };\n\n  static QueryParameters = {\n    f: 'json'\n  };\n\n  static Headers = {\n    Accept: 'application/json'\n  };\n\n  /**\n   * Initializes the parser with the given parameters\n   * @param {string} url     A valid and reachable ArcGIS MapServer URL\n   * @param {L.Map} map     A Leaflet Map object, which will be passed to all\n   * the layers in the resulting LayerHierarchy\n   * @param {object} [options] An optional configuration object\n   * @param {object} [options.data] The configuration options related to what data\n   * should be parsed from the MapServer to be included on NestedLayer objects\n   * @param {boolean} [options.data.scale=true] Include minZoom and maxZoom\n   * parameters on the NestedLayer\n   * @param {boolean} [options.data.defaultVisibility=true] Include the\n   * initial selected state of the NestedLayer\n   * @param {object} [options.hierarchyOptions={}] The configuration options\n   * the NestedHierarchy takes on instantiation\n   */\n  constructor(url, map, options) {\n    // ensure required parameters are present\n    if (typeof url == 'undefined') {\n      throw new Error('Missing URL when creating MapServerParser');\n    }\n    if (typeof map == 'undefined') {\n      throw new Error('Missing Leaflet map object when creating MapServerParser');\n    }\n\n    // save url\n    this._url = url;\n\n    // save map\n    this._map = map;\n\n    // set default options\n    this._defaults = {\n      data: {\n        scale: true,\n        defaultVisibility: true,\n        swatch: false\n      },\n      hierarchyOptions: {}\n    }\n\n    // merge options with defaults\n    this._options = {};\n    // https://lodash.com/docs/4.17.4#defaultsDeep\n    defaults(this._options, options, this.defaults);\n  }\n\n  /**\n   * MapServer URL\n   * @type {string}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Leaflet Map object\n   * @type {L.Map}\n   */\n  get map() {\n    return this._map;\n  }\n\n  /**\n   * Configuration options\n   * @type {object}\n   */\n  get options() {\n    return this._options;\n  }\n\n  /**\n   * Default configuration options\n   * @type {object}\n   */\n  get defaults() {\n    return this._defaults;\n  }\n\n  parse() {\n    // we have to wait for both xhr promises to resolve before we can begin processing\n    // note that Promise.join returns a promise that resolves to a LayerHierarchy\n    return Promise.join(this._queryLayers(), this._queryLegend(), (layerRes, legendRes) => {\n      // ensure we hit HTTP 2xx statuses\n      if (!layerRes.ok || !legendRes.ok) {\n        throw new Error('Bad request: HTTP status was not 2xx');\n      }\n\n      // parse the layerdata into JSON\n      let body = layerRes.body;\n      // ArcGIS does not properly set its Content-Type header\n      // so force JSON parsing if superagent did not parse automatically\n      if (layerRes.type !== MapServerParser.Headers.Accept) {\n        body = JSON.parse(layerRes.text);\n      }\n\n      // parse the legend into JSON\n      let legend = legendRes.body;\n      // ArcGIS does not properly set its Content-Type header\n      // so force JSON parsing if superagent did not parse automatically\n      if (legendRes.type !== MapServerParser.Headers.Accept) {\n        legend = JSON.parse(legendRes.text);\n      }\n      // the actual legend is located under the 'layers' node\n      legend = legend.layers;\n\n      // create the LayerHierarchy\n      var hierarchy = new LayerHierarchy(this.options.hierarchyOptions);\n\n      // move layers down as children of other layers\n      body.layers.forEach((node) => {\n        let layer = this._convertLayerNodeToNestedLayer(node, legend);\n        let parent = (node.parentLayer !== null ? node.parentLayer.id : undefined);\n        // if this layer has no parent, addLayer(...) will add as a root layer\n        hierarchy.addLayer(layer, parent);\n      });\n\n      // resolve the promise with the resulting LayerHierarchy\n      return hierarchy;\n    });\n  }\n\n  /**\n   * Queries the layers endpoint of the MapServer for layer data.\n   * @return {Promise} Promise that resolves the request.\n   */\n  _queryLayers() {\n    // assemble layerdata url\n    const layerdataURL = this.url + MapServerParser.APIEndpoints.layers;\n\n    // fetch layerdata as JSON\n    return request\n      .get(layerdataURL)\n      .set(MapServerParser.Headers)\n      .query(MapServerParser.QueryParameters)\n      .end();\n  }\n\n  _queryLegend() {\n    // assemble legend url\n    const legendURL = this.url + MapServerParser.APIEndpoints.legend;\n\n    // fetch legend as JSON\n    return request\n      .get(legendURL)\n      .set(MapServerParser.Headers)\n      .query(MapServerParser.QueryParameters)\n      .end();\n  }\n\n  _convertLayerNodeToNestedLayer = (node, legend) => {\n    let nestedLayerData = {\n      id: node.id,\n      name: node.name.trim(),\n      map: this.map\n    };\n    // Leaflet layer data\n    let leafletLayerData = {\n      url: MapServerParser._makeLayerURL(this.url, nestedLayerData.id)\n    };\n\n    // get scale/zoom data from layer node\n    if (this.options.data.scale) {\n      // converts scale factor from ArcGIS to Leaflet's zoom factor\n      // http://leafletjs.com/reference-1.1.0.html#crs-scale\n      // leafletLayerData.maxZoom = this.map.options.crs.zoom(node.maxScale);\n      // leafletLayerData.minZoom = this.map.options.crs.zoom(node.minScale);\n      console.warn('Floor\\'ing maxZoom and ceil\\'ing minZoom');\n      // console.log(nestedLayerData.name, 'minZoom', leafletLayerData.minZoom, 'maxZoom', leafletLayerData.maxZoom)\n      leafletLayerData.maxZoom = Math.floor(this.map.options.crs.zoom(node.maxScale));\n      leafletLayerData.minZoom = Math.ceil(this.map.options.crs.zoom(node.minScale));\n    }\n\n    // attach the swatch data\n    // if (this.options.data.swatch && legend[nestedLayerData.id].legend.length > 0) {\n    //   nestedLayerData.swatch = legend[nestedLayerData.id].legend[0].imageData;\n    //   console.log(nestedLayerData.name, nestedLayerData.id, nestedLayerData.swatch);\n    // }\n    if (this.options.data.swatch) {\n      nestedLayerData.swatch = MapServerParser._findSwatchInLegend(legend, nestedLayerData.id);\n    }\n\n    // attach the Leaflet layer object to the NestedLayer's data\n    nestedLayerData.layer = new FeatureLayer(leafletLayerData);\n\n    // create a new NestedLayer that wraps the Leaflet layer, map, etc.\n    let layer = new NestedLayer(nestedLayerData);\n\n    // set the selected state = to the node's default visibility state\n    if (this.options.data.defaultVisibility) {\n      layer.selected = node.defaultVisibility;\n    }\n\n    // returns a NestedLayer object\n    return layer;\n  }\n\n  static _findSwatchInLegend(legend, layerID) {\n    // if no swatches even exist (e.g. invalid legend)\n    if (legend.length <= 0) { return ''; }\n\n    // loop through to try to find a valid swatch\n    // this algorithm could be optimized from O(n) due to\n    // the sorted nature of the legend\n    // it just must account for the fact that a legend object may not exist for\n    // any given layer\n    for (let i = 0; i < legend.length; i++) {\n      if (legend[i].layerId == layerID && legend[i].legend.length > 0) {\n        return legend[i].legend[0].imageData;\n      }\n    }\n\n    // no swatch found\n    return '';\n  }\n\n  static _makeLayerURL(baseURL, layerID) {\n    if (typeof baseURL !== 'string') {\n      throw new Error('Base URL was undefined, null, or was not a string');\n    }\n    if (typeof layerID !== 'number') {\n      throw new Error('ID was undefined, null, or was not a number');\n    }\n\n    return baseURL + '/' + layerID.toString();\n  }\n\n}\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}