{"version":3,"sources":["Leaflet.LayerHierarchy.MapServerParser.js"],"names":["request","MapServerParser","url","map","options","_processLayerNode","layerFactory","node","layerData","id","name","leafletLayerData","_makeLayerURL","data","scale","maxZoom","zoom","maxScale","minZoom","minScale","layer","defaultVisibility","selected","Error","_url","_map","_defaults","hierarchyOptions","_options","defaults","p","resolve","reject","_queryLayers","then","res","ok","body","type","Headers","Accept","JSON","parse","text","hierarchy","layers","bind","makeLayer","layerdataURL","APISuffixes","get","set","query","JSONQueryParameters","end","baseURL","layerID","toString","legend","f"],"mappings":"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","file":"Leaflet.LayerHierarchy.MapServerParser.js","sourcesContent":["import LayerHierarchy from './Leaflet.LayerHierarchy';\n\nimport { defaultsDeep as defaults } from 'lodash';\n// superagent mimics the node 'request' library on the client side\n// used for xhr/ajax\nimport superagent from 'superagent';\nimport Promise from 'bluebird';\nimport superagentPromise from 'superagent-promise';\nconst request = superagentPromise(superagent, Promise);\nimport { FeatureLayerService } from 'esri-leaflet';\n\n/**\n * Parses the layer data served by an ArcGIS MapServer\n * @param {string} url A valid and reachable ArcGIS MapServer URL\n * @param {L.Map} map A Leaflet Map object, which will be passed to all\n * the layers in the resulting LayerHierarchy\n * @param {object} [options] An optional configuration object\n */\nexport default class MapServerParser {\n\n  static APISuffixes = {\n    layers: '/layers',\n    legend: '/legend'\n  };\n\n  static JSONQueryParameters = {\n    f: 'json'\n  };\n\n  static Headers = {\n    Accept: 'application/json'\n  };\n\n  /**\n   * Initializes the parser with the given parameters\n   * @param {string} url     A valid and reachable ArcGIS MapServer URL\n   * @param {L.Map} map     A Leaflet Map object, which will be passed to all\n   * the layers in the resulting LayerHierarchy\n   * @param {object} [options] An optional configuration object\n   * @param {object} [options.data] The configuration options related to what data\n   * should be parsed from the MapServer to be included on NestedLayer objects\n   * @param {boolean} [options.data.scale=true] Include minZoom and maxZoom\n   * parameters on the NestedLayer\n   * @param {boolean} [options.data.defaultVisibility=true] Include the\n   * initial selected state of the NestedLayer\n   * @param {object} [options.hierarchyOptions={}] The configuration options\n   * the NestedHierarchy takes on instantiation\n   */\n  constructor(url, map, options) {\n    // ensure required parameters are present\n    if (typeof url == 'undefined') {\n      throw new Error('Missing URL when creating MapServerParser');\n    }\n    if (typeof map == 'undefined') {\n      throw new Error('Missing Leaflet map object when creating MapServerParser');\n    }\n\n    // save url\n    this._url = url;\n\n    // save map\n    this._map = map;\n\n    // set default options\n    this._defaults = {\n      data: {\n        scale: true,\n        defaultVisibility: true\n      },\n      hierarchyOptions: {}\n    }\n\n    // merge options with defaults\n    this._options = {};\n    // https://lodash.com/docs/4.17.4#defaultsDeep\n    defaults(this._options, options, this.defaults);\n  }\n\n  /**\n   * MapServer URL\n   * @type {string}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Leaflet Map object\n   * @type {L.Map}\n   */\n  get map() {\n    return this._map;\n  }\n\n  /**\n   * Configuration options\n   * @type {object}\n   */\n  get options() {\n    return this._options;\n  }\n\n  /**\n   * Default configuration options\n   * @type {object}\n   */\n  get defaults() {\n    return this._defaults;\n  }\n\n  parse() {\n    // setup the promise we will return\n    const p = new Promise((resolve, reject) => {\n\n    });\n\n    // query the layers endpoint and resolve the promise\n    this._queryLayers().then((res) => {\n      // ensure we hit HTTP 2xx status\n      if (!res.ok) {\n        throw new Error('Non-HTTP status 200');\n      }\n\n      let body = res.body;\n      // ArcGIS does not properly set its Content-Type header\n      // so force JSON parsing if superagent did not parse automatically\n      if (res.type !== MapServerParser.Headers.Accept) {\n        body = JSON.parse(res.text);\n      }\n\n      // create the LayerHierarchy\n      let hierarchy = new LayerHierarchy(this.options.hierarchyOptions);\n\n      // loop through each layer and make a NestedLayer based on it\n      let layers = body.layers.map(\n        this._processLayerNode.bind(this, hierarchy.makeLayer)\n        );\n    });\n\n    return p;\n  }\n\n  /**\n   * Queries the layers endpoint of the MapServer for layer data.\n   * @return {Promise} Promise that resolves the request.\n   */\n  _queryLayers() {\n    // assemble layerdata url\n    const layerdataURL = this.url + MapServerParser.APISuffixes.layers;\n\n    // ArcGIS does not properly set its Content-Type header\n    // so force superagent to use JSON parsing\n    // superagent.parse['text/plain'] = JSON.parse;\n\n    // fetch layerdata as JSON\n    return request\n      .get(layerdataURL)\n      .set(MapServerParser.Headers)\n      .query(MapServerParser.JSONQueryParameters)\n      .end();\n  }\n\n  _processLayerNode = (layerFactory, node) => {\n    // NestedLayer data\n    let layerData = {\n      id: node.id,\n      name: node.name,\n      map: this.map\n    };\n    // Leaflet layer data\n    let leafletLayerData = {\n      url: MapServerParser._makeLayerURL(this.url, layerData.id)\n    };\n\n    // get scale/zoom data from layer node\n    if (this.options.data.scale) {\n      // converts scale factor from ArcGIS to Leaflet's zoom factor\n      // http://leafletjs.com/reference-1.1.0.html#crs-scale\n      leafletLayerData.maxZoom = this.map.zoom(node.maxScale);\n      leafletLayerData.minZoom = this.map.zoom(node.minScale);\n    }\n\n    // attach the Leaflet layer object to the NestedLayer's data\n    layerData.layer = new FeatureLayerService(leafletLayerData);\n\n    // use the provided NestedLayer factory to turn layerData into an owned NestedLayer\n    let layer = layerFactory(layerData);\n\n    // set the selected state = to the node's default visibility state\n    if (this.options.data.defaultVisibility) {\n      layer.selected = node.defaultVisibility;\n    }\n\n    // returns a NestedLayer object\n    return layer;\n  }\n\n  static _makeLayerURL(baseURL, layerID) {\n    if (typeof baseURL !== 'string') {\n      throw new Error('Base URL was undefined, null, or was not a string');\n    }\n    if (typeof layerID !== 'number') {\n      throw new Error('ID was undefined, null, or was not a number');\n    }\n\n    return baseURL + '/' + layerID.toString();\n  }\n\n}\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}