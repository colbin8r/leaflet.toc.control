{"version":3,"sources":["index.js"],"names":["NestedLayerTreeHelper","exports","NestedLayer","NestedDynamicMapLayer","Symbology","Control","namespace","Object","assign","nestedLayer","args","nestedDynamicMapLayer","symbology","control","window","L","TOC","LeafletTOC","module"],"mappings":";;AACA;;;;AACA;;;;AACA;;IAAYA,qB;;AACZ;;;;AACA;;;;;;;;AACA;AACA;AACA;;AAEA,IAAIC,WAAU;AACZC,mCADY;AAEZC,6CAFY;AAGZH,8CAHY;AAIZI,iCAJY;AAKZC;AACA;AACA;AACA;;;AAGF;AACA;AAZc,CAAd,C,CAVA;AAuBA,IAAIC,YAAYC,OAAOC,MAAP,CAAc,EAAd,EAAkBP,QAAlB,CAAhB;;AAEA;AACA;AACAK,UAAUG,WAAV,GAAwB,SAASA,WAAT,GAA8B;AAAA,oCAANC,IAAM;AAANA,QAAM;AAAA;;AACpD,4CAAWT,SAAQC,WAAnB,gBAAkCQ,IAAlC;AACD,CAFD;AAGAJ,UAAUK,qBAAV,GAAkC,SAASA,qBAAT,GAAwC;AAAA,qCAAND,IAAM;AAANA,QAAM;AAAA;;AACxE,4CAAWT,SAAQE,qBAAnB,gBAA4CO,IAA5C;AACD,CAFD;AAGA;AACAJ,UAAUM,SAAV,GAAsB,SAASA,SAAT,GAA4B;AAAA,qCAANF,IAAM;AAANA,QAAM;AAAA;;AAChD,4CAAWT,SAAQG,SAAnB,gBAAgCM,IAAhC;AACD,CAFD;AAGAJ,UAAUO,OAAV,GAAoB,SAASA,OAAT,GAA0B;AAAA,qCAANH,IAAM;AAANA,QAAM;AAAA;;AAC5C,4CAAWT,SAAQI,OAAnB,gBAA8BK,IAA9B;AACD,CAFD;;AAIA,IAAI,OAAOI,MAAP,KAAkB,WAAlB,IAAiC,OAAOA,OAAOC,CAAd,KAAoB,WAAzD,EAAsE;AACpE;AACAD,SAAOC,CAAP,CAASC,GAAT,GAAeV,SAAf;AACA;AACA;AACAQ,SAAOC,CAAP,CAASV,OAAT,CAAiBW,GAAjB,GAAuBV,UAAUD,OAAjC;AACD,CAND,MAMO,IAAI,OAAOS,MAAP,KAAkB,WAAtB,EAAmC;AACxC;AACAA,SAAOG,UAAP,GAAoBX,SAApB;AACD,CAHM,MAGA;AACL;AACAL,WAAQc,CAAR,GAAY;AACVC,SAAKV;AADK,GAAZ;AAGD;;AAEDY,OAAOjB,OAAP,GAAiBA,QAAjB","file":"index.js","sourcesContent":["/* global window */\nimport NestedLayer from './Leaflet.TOC.NestedLayer';\nimport NestedDynamicMapLayer from './Leaflet.TOC.NestedDynamicMapLayer';\nimport * as NestedLayerTreeHelper from './Leaflet.TOC.NestedLayerTreeHelper';\nimport Symbology from './Leaflet.TOC.Symbology';\nimport Control from './Leaflet.TOC.Control';\n// import LayerHierarchy from './Leaflet.LayerHierarchy';\n// import MapServerParser from './Leaflet.LayerHierarchy.MapServerParser';\n// import NestedLayers from './Leaflet.Control.NestedLayers';\n\nlet exports = {\n  NestedLayer,\n  NestedDynamicMapLayer,\n  NestedLayerTreeHelper,\n  Symbology,\n  Control\n  // LayerHierarchy,\n  // MapServerParser,\n  // NestedLayers\n}\n\n// decide later whether to attach to the global L by attaching everything we would attach\n// to the global L to a separate 'namespace' object\nlet namespace = Object.assign({}, exports);\n\n// create the standard factory methods that Leaflet plugins are supposed to expose\n// using ES6 spread notation means always up-to-date constructor parameters\nnamespace.nestedLayer = function nestedLayer(...args) {\n  return new exports.NestedLayer(...args);\n};\nnamespace.nestedDynamicMapLayer = function nestedDynamicMapLayer(...args) {\n  return new exports.NestedDynamicMapLayer(...args);\n}\n// no factory for NestedLayerTreeHelper\nnamespace.symbology = function symbology(...args) {\n  return new exports.Symbology(...args);\n}\nnamespace.control = function control(...args) {\n  return new exports.Control(...args);\n}\n\nif (typeof window !== 'undefined' && typeof window.L !== 'undefined') {\n  // global L and window present\n  window.L.TOC = namespace;\n  // specially alias plugin (a Leaflet control) to the L.Control.TOC\n  // to emulate other control plugins' best practice\n  window.L.Control.TOC = namespace.Control;\n} else if (typeof window !== 'undefined') {\n  // global L and window missing\n  window.LeafletTOC = namespace;\n} else {\n  // if there is no global window, stay out of the global namespace\n  exports.L = {\n    TOC: namespace\n  };\n}\n\nmodule.exports = exports;\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}