{"version":3,"sources":["Leaflet.LayerHierarchy.js"],"names":["LayerHierarchy","options","_options","layers","followAncestorVisibility","propogateDeselectToChildren","followAncestorMutability","Object","assign","_layers","validateEnabledStates","ownAllLayers","layer","parentID","TypeError","ownLayer","getLayerByID","addChild","push","id","children","i","length","recursiveResult","newEnabledValue","rootLayers","enabled","hasChildren","owner","layerData","l","ownChildren"],"mappings":"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","file":"Leaflet.LayerHierarchy.js","sourcesContent":["import NestedLayer from './Leaflet.NestedLayer';\n\n/**\n * Represents a non-rooted tree structure of NestedLayer objects\n * @param {object} options Configuration options that dictate how the tree\n * should behave\n */\nexport default class LayerHierarchy {\n\n  /**\n   * @param {object} options Configuration options\n   * @param {NestedLayer[]} [options.layers=[]] Layers to include at the root\n   * level\n   * @param {boolean} [options.followAncestorVisibility=true] {@link\n   * #NestedLayers#constructor See the plugin constructor.}\n   * @param {boolean} [options.propogateDeselectToChildren=false] {@link\n   * #NestedLayers#constructor See the plugin constructor.}\n   * @param {boolean} [options.followAncestorMutability=true] {@link\n   * #NestedLayers#constructor See the plugin constructor.}\n   */\n  constructor(options) {\n    // for the layers parameter, ensure that we are at least passed an array\n    // otherwise, default to empty array\n\n    // default options\n    this._options = {\n      // 'layers' will be deleted by the end of the constructor\n      layers: [],\n      followAncestorVisibility: true,\n      propogateDeselectToChildren: false,\n      followAncestorMutability: true\n    };\n\n    // overwrite defaults with passed options\n    Object.assign(this._options, options);\n\n    // extract the 'layers' property from 'options' into its own property\n    this._layers = this.options.layers;\n    delete this._options.layers;\n\n    this.validateEnabledStates();\n\n    this.ownAllLayers(this.layers);\n  }\n\n  /**\n   * Configuration options\n   * @type {object}\n   */\n  get options() {\n    return this._options;\n  }\n\n  /**\n   * Adds a new layer into the tree. Defaults to insertion at the root of the\n   * tree, but passing a the ID of another layer will insert the layer as a\n   * child of that parent.\n   * @param {NestedLayer} layer    The layer to insert\n   * @param {?number} [parentID=null] The ID of a parent to insert underneath\n   */\n  addLayer(layer, parentID) {\n    // id, name, layer, defaultVisibility, minScale, maxScale, children\n    // layer should be a NestedLayer\n\n    if (!(layer instanceof NestedLayer)) {\n      throw new TypeError('layer is not a NestedLayer');\n    }\n\n    // take ownership of the layer\n    this.ownLayer(layer);\n\n    if (typeof parentID != 'undefined') {\n      // add as child\n      this.getLayerByID(parentID).addChild(layer);\n    } else {\n      // no parent, add at root level\n      this._layers.push(layer);\n    }\n  }\n\n  /**\n   * Finds a layer in the tree by ID. Traverses the tree recurisvely until it\n   * is found. Don't pass children unless you want to search a specific\n   * subtree.\n   * @param  {number}          id       The layer ID to search for\n   * @param  {NestedLayer[]}   [children=this.layers] A subtree to search\n   * @return {?NestedLayer}     The layer if found, or null otherwise.\n   */\n  getLayerByID(id, children) {\n\n    // if the function was not called recursively\n    if (!children) {\n      children = this._layers;\n    }\n\n    for (let i = 0; i < children.length; i++) {\n\n      // if the child matches\n      if (children[i].id == id) {\n        // return the child\n        return children[i];\n\n      } else {\n\n        // if the child has its own children\n        if (children[i].children && children[i].children.length > 0) {\n\n          // reucrisvely check them\n          let recursiveResult = this.getLayerByID(id, children[i].children);\n          if (recursiveResult !== null) {\n            return recursiveResult;\n          }\n\n        }\n      }\n\n    }\n\n    // if execution reaches here, no layers in this tree or subtree have the requested id\n    return null;\n  }\n\n  /**\n   * Root-level NestedLayer layers\n   * @type {NestedLayer[]}\n   */\n  get layers() {\n    return this._layers;\n  }\n  /**\n   * {@link #LayerHierarchy#layers Root-level NestedLayer layers}\n   * @type {NestedLayer[]}\n   */\n  get rootLayers() {\n    return this.layers;\n  }\n\n  // check all the children to ensure that they are all enabled/disabled as appropriate\n  // the highest layer takes precedence over lower layers\n  // i.e. if a root-level layer is disabled, then all its children will be disabled as well\n  // parameters should be undefined when called the first time; the function is recursive\n  validateEnabledStates(layers, newEnabledValue) {\n    // first call? then layers = the whole true\n    if (typeof layers === 'undefined') {\n      // console.log('validateEnabledStates: first call');\n      layers = this.rootLayers;\n    }\n\n    for (let i = 0; i < layers.length; i++) {\n      // console.log('validateEnabledStates: checking', layers[i].name);\n\n      // if we have a specific enabled value, set the children to that\n      if (typeof newEnabledValue !== 'undefined') {\n        // console.log('validateEnabledStates: setting', layers[i].name, 'to', newEnabledValue);\n        layers[i].enabled = newEnabledValue;\n      }\n\n      // if the layer has children, repeat this process on them\n      // console.log('validateEnabledStates: does', layers[i].name, 'have children?', (layers[i].hasChildren ? 'yes' : 'no'));\n      if (layers[i].hasChildren) {\n        // console.log('validateEnabledStates: setting children of', layers[i].name, 'to', layers[i].enabled);\n        this.validateEnabledStates(layers[i].children, layers[i].enabled)\n      }\n\n    }\n\n  }\n\n  /**\n   * Checks if this LayerHierarchy owns the provided layer\n   * @param  {NestedLayer} layer The layer to check\n   * @return {boolean}       True if the layer is owned by this hierarchy; false otherwise\n   */\n  ownsLayer(layer) {\n    return layer.owner === this;\n  }\n\n  /**\n   * Factory method for making a new NestedLayer that is owned by this hierarchy\n   * @param  {object} layerData The same object you would provide to the {@link #NestedLayer#constructor constructor of NestedLayer}\n   * @return {NestedLayer}           A NestedLayer owned by this hierarchy\n   */\n  makeLayer(layerData) {\n    const l = new NestedLayer(layerData);\n    l.owner = this;\n    return l;\n  }\n\n  /**\n   * Take ownership of a layer\n   * @param  {NestedLayer} layer The layer to become the owner of\n   */\n  ownLayer(layer) {\n    layer.owner = this;\n  }\n\n  /**\n   * Take ownership of a layer subtree AND those layers' children\n   * @param  {NestedLayer[]} layers The layers to become the owner of\n   */\n  ownAllLayers(layers) {\n    for (let i = 0; i < layers.length; i++) {\n      this.ownLayer(layers[i]);\n      layers[i].ownChildren();\n    }\n  }\n\n}\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}