{"version":3,"sources":["Leaflet.LayerHierarchy.js"],"names":["LayerHierarchy","options","_layers","Array","isArray","layers","layer","parentID","TypeError","getLayerByID","addChild","push","id","children","i","length","recursiveResult","window","L","layerHierarchy"],"mappings":";;;;;;;qjBAAA;;;AACA;;;;IAEaA,c,WAAAA,c;AACX,0BAAYC,OAAZ,EAAqB;AAAA;;AACnB;;AAEA;AACA;AACA,SAAKC,OAAL,GAAgBC,MAAMC,OAAN,CAAcH,QAAQI,MAAtB,IAAgCJ,QAAQI,MAAxC,GAAiD,EAAjE;AACD;;AAED;AACA;AACA;;;;;6BACSC,K,EAAOC,Q,EAAU;AACxB;AACA;;AAEA,UAAI,EAAED,qCAAF,CAAJ,EAAqC;AACnC,cAAM,IAAIE,SAAJ,CAAc,4BAAd,CAAN;AACD;;AAED,UAAI,OAAOD,QAAP,IAAmB,WAAvB,EAAoC;AAClC;AACA,aAAKE,YAAL,CAAkBF,QAAlB,EAA4BG,QAA5B,CAAqCJ,KAArC;AACD,OAHD,MAGO;AACL;AACA,aAAKJ,OAAL,CAAaS,IAAb,CAAkBL,KAAlB;AACD;AACF;;AAED;;;;iCACaM,E,EAAIC,Q,EAAU;;AAEzB;AACA,UAAI,CAACA,QAAL,EAAe;AACbA,mBAAW,KAAKX,OAAhB;AACD;;AAED,WAAK,IAAIY,IAAI,CAAb,EAAgBA,IAAID,SAASE,MAA7B,EAAqCD,GAArC,EAA0C;;AAExC;AACA,YAAID,SAASC,CAAT,EAAYF,EAAZ,IAAkBA,EAAtB,EAA0B;AACxB;AACA,iBAAOC,SAASC,CAAT,CAAP;AAED,SAJD,MAIO;;AAEL;AACA,cAAID,SAASC,CAAT,EAAYD,QAAZ,IAAwBA,SAASC,CAAT,EAAYD,QAAZ,CAAqBE,MAArB,GAA8B,CAA1D,EAA6D;;AAE3D;AACA,gBAAIC,kBAAkB,KAAKP,YAAL,CAAkBG,EAAlB,EAAsBC,SAASC,CAAT,EAAYD,QAAlC,CAAtB;AACA,gBAAIG,oBAAoB,IAAxB,EAA8B;AAC5B,qBAAOA,eAAP;AACD;AAEF;AACF;AAEF;;AAED;AACA,aAAO,IAAP;AACD;;AAED;;AAEA;;AAEA;AACA;AACA;;;;;;;AAGF,IAAI,OAAOC,MAAP,IAAiB,WAArB,EAAkC;AAChCC,IAAEC,cAAF,GAAmB,SAASA,cAAT,CAAwBlB,OAAxB,EAAiC;AAClD,WAAO,IAAIiB,EAAElB,cAAN,CAAqBC,OAArB,CAAP;AACD,GAFD;AAGD","file":"Leaflet.LayerHierarchy.js","sourcesContent":["/* global L, window */\nimport { NestedLayer } from './Leaflet.NestedLayer';\n\nexport class LayerHierarchy {\n  constructor(options) {\n    // Object.assign(this, options);\n\n    // for the layers parameter, ensure that we are at least passed an array\n    // otherwise, default to empty array\n    this._layers = (Array.isArray(options.layers) ? options.layers : []);\n  }\n\n  // adds a new NestedLayer object into the tree\n  // defaults to insertion at the root of the tree, but with a parentID\n  // you may insert underneath any other NestedLayer in the tree\n  addLayer(layer, parentID) {\n    // id, name, layer, defaultVisibility, minScale, maxScale, children\n    // layer should be a NestedLayer\n\n    if (!(layer instanceof NestedLayer)) {\n      throw new TypeError('layer is not a NestedLayer');\n    }\n\n    if (typeof parentID != 'undefined') {\n      // add as child\n      this.getLayerByID(parentID).addChild(layer);\n    } else {\n      // no parent, add at root level\n      this._layers.push(layer);\n    }\n  }\n\n  // looks up NestedLayer object by traversing the tree\n  getLayerByID(id, children) {\n\n    // if the function was not called recursively\n    if (!children) {\n      children = this._layers;\n    }\n\n    for (var i = 0; i < children.length; i++) {\n\n      // if the child matches\n      if (children[i].id == id) {\n        // return the child\n        return children[i];\n\n      } else {\n\n        // if the child has its own children\n        if (children[i].children && children[i].children.length > 0) {\n\n          // reucrisvely check them\n          let recursiveResult = this.getLayerByID(id, children[i].children);\n          if (recursiveResult !== null) {\n            return recursiveResult;\n          }\n\n        }\n      }\n\n    }\n\n    // if execution reaches here, no layers in this subtree have the requested id\n    return null;\n  }\n\n  // addToMapOverlays(map) {\n\n  // }\n\n  // get person() {\n  //   return this.props.person;\n  // }\n}\n\nif (typeof window != 'undefined') {\n  L.layerHierarchy = function layerHierarchy(options) {\n    return new L.LayerHierarchy(options);\n  };\n}\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}