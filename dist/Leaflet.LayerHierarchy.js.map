{"version":3,"sources":["Leaflet.LayerHierarchy.js"],"names":["LayerHierarchy","options","_options","layers","followAncestorVisibility","propogateDeselectToChildren","followAncestorMutability","Object","assign","_layers","validateEnabledStates","ownAllLayers","layer","parentID","TypeError","owner","getLayerByID","addChild","push","id","children","i","length","recursiveResult","newEnabledValue","rootLayers","enabled","hasChildren","layerData","l","ownLayer","ownChildren"],"mappings":"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","file":"Leaflet.LayerHierarchy.js","sourcesContent":["import NestedLayer from './Leaflet.NestedLayer';\n\nexport default class LayerHierarchy {\n  constructor(options) {\n    // for the layers parameter, ensure that we are at least passed an array\n    // otherwise, default to empty array\n\n    // default options\n    this._options = {\n      // 'layers' will be deleted by the end of the constructor\n      layers: [],\n      followAncestorVisibility: true,\n      propogateDeselectToChildren: false,\n      followAncestorMutability: true\n    };\n\n    // overwrite defaults with passed options\n    Object.assign(this._options, options);\n\n    // extract the 'layers' property from 'options' into its own property\n    this._layers = this.options.layers;\n    delete this._options.layers;\n\n    this.validateEnabledStates();\n\n    this.ownAllLayers(this.layers);\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  // adds a new NestedLayer object into the tree\n  // defaults to insertion at the root of the tree, but with a parentID\n  // you may insert underneath any other NestedLayer in the tree\n  addLayer(layer, parentID) {\n    // id, name, layer, defaultVisibility, minScale, maxScale, children\n    // layer should be a NestedLayer\n\n    if (!(layer instanceof NestedLayer)) {\n      throw new TypeError('layer is not a NestedLayer');\n    }\n\n    // take ownership of the layer\n    layer.owner = this;\n\n    if (typeof parentID != 'undefined') {\n      // add as child\n      this.getLayerByID(parentID).addChild(layer);\n    } else {\n      // no parent, add at root level\n      this._layers.push(layer);\n    }\n  }\n\n  // looks up NestedLayer object by traversing the tree\n  // when calling, do not pass a 'children' parameter\n  getLayerByID(id, children) {\n\n    // if the function was not called recursively\n    if (!children) {\n      children = this._layers;\n    }\n\n    for (let i = 0; i < children.length; i++) {\n\n      // if the child matches\n      if (children[i].id == id) {\n        // return the child\n        return children[i];\n\n      } else {\n\n        // if the child has its own children\n        if (children[i].children && children[i].children.length > 0) {\n\n          // reucrisvely check them\n          let recursiveResult = this.getLayerByID(id, children[i].children);\n          if (recursiveResult !== null) {\n            return recursiveResult;\n          }\n\n        }\n      }\n\n    }\n\n    // if execution reaches here, no layers in this tree or subtree have the requested id\n    return null;\n  }\n\n  // getRootLayers() {\n  //   return this._layers;\n  // }\n\n  get layers() {\n    return this._layers;\n  }\n  get rootLayers() {\n    return this.layers;\n  }\n\n  // check all the children to ensure that they are all enabled/disabled as appropriate\n  // the highest layer takes precedence over lower layers\n  // i.e. if a root-level layer is disabled, then all its children will be disabled as well\n  // parameters should be undefined when called the first time; the function is recursive\n  validateEnabledStates(layers, newEnabledValue) {\n    // first call? then layers = the whole true\n    if (typeof layers === 'undefined') {\n      // console.log('validateEnabledStates: first call');\n      layers = this.rootLayers;\n    }\n\n    for (let i = 0; i < layers.length; i++) {\n      // console.log('validateEnabledStates: checking', layers[i].name);\n\n      // if we have a specific enabled value, set the children to that\n      if (typeof newEnabledValue !== 'undefined') {\n        // console.log('validateEnabledStates: setting', layers[i].name, 'to', newEnabledValue);\n        layers[i].enabled = newEnabledValue;\n      }\n\n      // if the layer has children, repeat this process on them\n      // console.log('validateEnabledStates: does', layers[i].name, 'have children?', (layers[i].hasChildren ? 'yes' : 'no'));\n      if (layers[i].hasChildren) {\n        // console.log('validateEnabledStates: setting children of', layers[i].name, 'to', layers[i].enabled);\n        this.validateEnabledStates(layers[i].children, layers[i].enabled)\n      }\n\n    }\n\n  }\n\n  ownsLayer(layer) {\n    return layer.owner === this;\n  }\n\n  makeLayer(layerData) {\n    const l = new NestedLayer(layerData);\n    l.owner = this;\n    return l;\n  }\n\n  ownLayer(layer) {\n    layer.owner = this;\n  }\n\n  ownAllLayers(layers) {\n    for (let i = 0; i < layers.length; i++) {\n      this.ownLayer(layers[i]);\n      layers[i].ownChildren();\n    }\n  }\n\n}\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}