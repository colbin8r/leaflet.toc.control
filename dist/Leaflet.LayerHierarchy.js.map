{"version":3,"sources":["Leaflet.LayerHierarchy.js"],"names":["LayerHierarchy","options","_layers","Array","isArray","layers","validateEnabledStates","layer","parentID","TypeError","getLayerByID","addChild","push","id","children","i","length","recursiveResult","newEnabledValue","getRootLayers","enabled","hasChildren"],"mappings":";;;;;;;;AAAA;;;;;;;;IAEqBA,c;AACnB,0BAAYC,OAAZ,EAAqB;AAAA;;AACnB;AACA;AACA,QAAI,OAAOA,OAAP,KAAmB,WAAvB,EAAoC;AAClCA,gBAAU,EAAV;AACD;AACD,SAAKC,OAAL,GAAgBC,MAAMC,OAAN,CAAcH,QAAQI,MAAtB,IAAgCJ,QAAQI,MAAxC,GAAiD,EAAjE;;AAEA,SAAKC,qBAAL;AACD;;AAED;AACA;AACA;;;;;6BACSC,K,EAAOC,Q,EAAU;AACxB;AACA;;AAEA,UAAI,EAAED,kCAAF,CAAJ,EAAqC;AACnC,cAAM,IAAIE,SAAJ,CAAc,4BAAd,CAAN;AACD;;AAED,UAAI,OAAOD,QAAP,IAAmB,WAAvB,EAAoC;AAClC;AACA,aAAKE,YAAL,CAAkBF,QAAlB,EAA4BG,QAA5B,CAAqCJ,KAArC;AACD,OAHD,MAGO;AACL;AACA,aAAKL,OAAL,CAAaU,IAAb,CAAkBL,KAAlB;AACD;AACF;;AAED;AACA;;;;iCACaM,E,EAAIC,Q,EAAU;;AAEzB;AACA,UAAI,CAACA,QAAL,EAAe;AACbA,mBAAW,KAAKZ,OAAhB;AACD;;AAED,WAAK,IAAIa,IAAI,CAAb,EAAgBA,IAAID,SAASE,MAA7B,EAAqCD,GAArC,EAA0C;;AAExC;AACA,YAAID,SAASC,CAAT,EAAYF,EAAZ,IAAkBA,EAAtB,EAA0B;AACxB;AACA,iBAAOC,SAASC,CAAT,CAAP;AAED,SAJD,MAIO;;AAEL;AACA,cAAID,SAASC,CAAT,EAAYD,QAAZ,IAAwBA,SAASC,CAAT,EAAYD,QAAZ,CAAqBE,MAArB,GAA8B,CAA1D,EAA6D;;AAE3D;AACA,gBAAIC,kBAAkB,KAAKP,YAAL,CAAkBG,EAAlB,EAAsBC,SAASC,CAAT,EAAYD,QAAlC,CAAtB;AACA,gBAAIG,oBAAoB,IAAxB,EAA8B;AAC5B,qBAAOA,eAAP;AACD;AAEF;AACF;AAEF;;AAED;AACA,aAAO,IAAP;AACD;;;oCAEe;AACd,aAAO,KAAKf,OAAZ;AACD;;AAED;AACA;AACA;AACA;;;;0CACsBG,M,EAAQa,e,EAAiB;AAC7C;AACA,UAAI,OAAOb,MAAP,KAAkB,WAAtB,EAAmC;AACjC;AACAA,iBAAS,KAAKc,aAAL,EAAT;AACD;;AAED,WAAK,IAAIJ,IAAI,CAAb,EAAgBA,IAAIV,OAAOW,MAA3B,EAAmCD,GAAnC,EAAwC;AACtC;;AAEA;AACA,YAAI,OAAOG,eAAP,KAA2B,WAA/B,EAA4C;AAC1C;AACAb,iBAAOU,CAAP,EAAUK,OAAV,GAAoBF,eAApB;AACD;;AAED;AACA;AACA,YAAIb,OAAOU,CAAP,EAAUM,WAAd,EAA2B;AACzB;AACA,eAAKf,qBAAL,CAA2BD,OAAOU,CAAP,EAAUD,QAArC,EAA+CT,OAAOU,CAAP,EAAUK,OAAzD;AACD;AAEF;AAEF;;;;;;kBArGkBpB,c","file":"Leaflet.LayerHierarchy.js","sourcesContent":["import NestedLayer from './Leaflet.NestedLayer';\n\nexport default class LayerHierarchy {\n  constructor(options) {\n    // for the layers parameter, ensure that we are at least passed an array\n    // otherwise, default to empty array\n    if (typeof options === 'undefined') {\n      options = {};\n    }\n    this._layers = (Array.isArray(options.layers) ? options.layers : []);\n\n    this.validateEnabledStates();\n  }\n\n  // adds a new NestedLayer object into the tree\n  // defaults to insertion at the root of the tree, but with a parentID\n  // you may insert underneath any other NestedLayer in the tree\n  addLayer(layer, parentID) {\n    // id, name, layer, defaultVisibility, minScale, maxScale, children\n    // layer should be a NestedLayer\n\n    if (!(layer instanceof NestedLayer)) {\n      throw new TypeError('layer is not a NestedLayer');\n    }\n\n    if (typeof parentID != 'undefined') {\n      // add as child\n      this.getLayerByID(parentID).addChild(layer);\n    } else {\n      // no parent, add at root level\n      this._layers.push(layer);\n    }\n  }\n\n  // looks up NestedLayer object by traversing the tree\n  // when calling, do not pass a 'children' parameter\n  getLayerByID(id, children) {\n\n    // if the function was not called recursively\n    if (!children) {\n      children = this._layers;\n    }\n\n    for (let i = 0; i < children.length; i++) {\n\n      // if the child matches\n      if (children[i].id == id) {\n        // return the child\n        return children[i];\n\n      } else {\n\n        // if the child has its own children\n        if (children[i].children && children[i].children.length > 0) {\n\n          // reucrisvely check them\n          let recursiveResult = this.getLayerByID(id, children[i].children);\n          if (recursiveResult !== null) {\n            return recursiveResult;\n          }\n\n        }\n      }\n\n    }\n\n    // if execution reaches here, no layers in this tree or subtree have the requested id\n    return null;\n  }\n\n  getRootLayers() {\n    return this._layers;\n  }\n\n  // check all the children to ensure that they are all enabled/disabled as appropriate\n  // the highest layer takes precedence over lower layers\n  // i.e. if a root-level layer is disabled, then all its children will be disabled as well\n  // parameters should be undefined when called the first time; the function is recursive\n  validateEnabledStates(layers, newEnabledValue) {\n    // first call? then layers = the whole true\n    if (typeof layers === 'undefined') {\n      // console.log('validateEnabledStates: first call');\n      layers = this.getRootLayers();\n    }\n\n    for (let i = 0; i < layers.length; i++) {\n      // console.log('validateEnabledStates: checking', layers[i].name);\n\n      // if we have a specific enabled value, set the children to that\n      if (typeof newEnabledValue !== 'undefined') {\n        // console.log('validateEnabledStates: setting', layers[i].name, 'to', newEnabledValue);\n        layers[i].enabled = newEnabledValue;\n      }\n\n      // if the layer has children, repeat this process on them\n      // console.log('validateEnabledStates: does', layers[i].name, 'have children?', (layers[i].hasChildren ? 'yes' : 'no'));\n      if (layers[i].hasChildren) {\n        // console.log('validateEnabledStates: setting children of', layers[i].name, 'to', layers[i].enabled);\n        this.validateEnabledStates(layers[i].children, layers[i].enabled)\n      }\n\n    }\n\n  }\n\n}\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}