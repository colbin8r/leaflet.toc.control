{"version":3,"sources":["Leaflet.NestedLayer.js"],"names":["NestedLayer","props","_handleMapZoom","zoom","map","getZoom","minZoom","maxZoom","_detach","_attach","_props","children","enabled","selected","swatch","_isAttached","id","Error","name","layer","Object","assign","select","undefined","on","owner","child","TypeError","push","_applyStateChangeToAllChildren","prop","val","i","length","hasChildren","addLayer","removeLayer","disabled","enableChildren","disableChildren","_owner","options"],"mappings":"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","file":"Leaflet.NestedLayer.js","sourcesContent":["/**\n * Wraps a {@link http://leafletjs.com/reference-1.1.0.html#layer Leaflet\n * layer} to allow that layer to be the \"parent\" of other layers by having\n * \"child\" layers\n * @param {object} props The layer data\n */\nexport default class NestedLayer {\n\n  /**\n   *\n   * @param {object} props The layer data\n   * @param {number} props.id The layer's unique ID number\n   * @param {string} props.name The layer's unique name\n   * @param {L.Layer} props.layer A {@link\n   * http://leafletjs.com/reference-1.1.0.html#layer Leaflet layer}\n   * @param {L.Map} props.map {@link\n   * http://leafletjs.com/reference-1.1.0.html#map Leaflet map} to attach to\n   * @param {boolean} [props.enabled=true] Initial enabled state of the layer\n   * @param {boolean} [props.selected=false] Initial selected state of the layer\n   * @param {string} [props.swatch=''] Base64 encoded swatch PNG\n   * @param {NestedLayer[]} [props.children=[]] Child layers\n   * @param {number} [props.minZoom] Minimum zoom level that the layer should be visible\n   * @param {number} [props.maxZoom] Maximum zoom level that the layer should be visible\n   */\n  constructor(props) {\n    // set default props for optional props\n    this._props = { children: [], enabled: true, selected: false, swatch: '' };\n    this._isAttached = false;\n\n    // verify that all required arguments are present\n    if (typeof props.id == 'undefined') {\n      throw new Error('Missing ID when creating NestedLayer');\n    }\n    if (typeof props.name == 'undefined') {\n      throw new Error('Missing name when creating NestedLayer');\n    }\n    if (typeof props.layer == 'undefined') {\n      throw new Error('Missing layer object when creating NestedLayer');\n    }\n    if (typeof props.map == 'undefined') {\n      throw new Error('Missing map object when creating NestedLayer');\n    }\n\n    Object.assign(this._props, props);\n\n    // if this layer is starting off selected, attach to the map\n    // calling this.select() ensures that we follow any other attachment rules\n    // built into the 'selected' setter\n    if (this.selected) {\n      this.select();\n    }\n\n    // if the zoom properties are on the leaflet layer object, copy them up to the\n    // NestedLayer object\n    if (this.layer.minZoom !== undefined && this.layer.maxZoom !== undefined) {\n      this._props.minZoom = this.layer.minZoom;\n      this._props.maxZoom = this.layer.maxZoom;\n    }\n\n    // if this layer has zoom data, we need to handle the case where the user zooms to a level where\n    // our layer should be disabled according to the minZoom/maxZoom contained in the layer object\n    if (this.minZoom !== undefined && this.maxZoom !== undefined) {\n      this.map.on('zoomend', this._handleMapZoom);\n    }\n  }\n\n  /**\n   * Layer ID\n   * @type {number}\n   */\n  get id() {\n    return this._props.id;\n  }\n\n  /**\n   * Layer name\n   * @type {string}\n   */\n  get name() {\n    return this._props.name;\n  }\n\n  /**\n   * Underlying Leaflet layer\n   * @type {L.Layer}\n   */\n  get layer() {\n    return this._props.layer;\n  }\n\n  /**\n   * Leaflet Map to attach to\n   * @type {L.Map}\n   */\n  get map() {\n    return this._props.map;\n  }\n\n  /**\n   * Base64 encoded swatch PNG\n   * @type {string}\n   */\n  get swatch() {\n    return this._props.swatch;\n  }\n\n  /**\n   * Child layers\n   * @type {NestedLayer[]}\n   */\n  get children() {\n    return this._props.children;\n  }\n\n  /**\n   * Minimum zoom level for this layer to be visible\n   * @type {number}\n   */\n  get minZoom() {\n    return this._props.minZoom;\n  }\n\n  /**\n   * Maximum zoom level for this layer to be visible\n   * @type {number}\n   */\n  get maxZoom() {\n    return this._props.maxZoom;\n  }\n\n  // enabled = user may freely toggle this layer on and off\n  // disabled = user may not toggle the layer\n  // disabling always deselects the layer, but the selected state is persisted, so that if\n  // the layer is re-enabled, the selected state is what it was prior to disabling\n  // i.e. if disabled, always deselected\n  // this logic is handled in the .selected getter\n\n  /**\n   * Whether the user may freely toggle this layer on and off\n   * @type {boolean}\n   */\n  get enabled() {\n    return this._props.enabled;\n  }\n  set enabled(val) {\n    this._props.enabled = val;\n\n    // if disabling, detach from map\n    if (!val) {\n      this._detach();\n\n    // if enabling, and marked selected (i.e. \"re-enabling\"), attach to map\n    } else if (this._props.selected) {\n      this._attach();\n    }\n  }\n  /**\n   * The inverse of #enabled\n   * @type {boolean}\n   */\n  get disabled() {\n    return !this.enabled;\n  }\n\n  /** Enable the layer */\n  enable() {\n    this.enabled = true;\n  }\n  /** Disable the layer */\n  disable() {\n    this.enabled = false;\n  }\n  /** Toggle the layer's enabled state */\n  toggleEnabled() {\n    this.enabled = !this.enabled;\n  }\n\n  // selected = layer present on the map\n  // deselected = layer not present on the map\n  get selected() {\n    if (this.disabled) {\n      return false;\n    } else {\n      return this._props.selected;\n    }\n  }\n  set selected(val) {\n    this._props.selected = val;\n\n    // attach/detach from map when needed\n    // disable children from selection when unselected\n    if (this.selected) {\n      this._attach();\n      this.enableChildren();\n    } else {\n      this._detach();\n      this.disableChildren();\n    }\n  }\n  get deselected() {\n    return !this.selected;\n  }\n  select() {\n    this.selected = true;\n  }\n  deselect() {\n    this.selected = false;\n  }\n  toggleSelected() {\n    this.selected = !this.selected;\n  }\n\n  // this is used to track what programmatic object owns this NestedLayer\n  get owner() {\n    return this._owner;\n  }\n  set owner(val) {\n    this._owner = val;\n  }\n  // checks ownership\n  isOwnedBy(owner) {\n    return this.owner === owner;\n  }\n\n  // options come from the layers owner\n  // will return null if there is no owner\n  get options() {\n    if (typeof this.owner === 'undefined') {\n      return null;\n    } else {\n      return this.owner.options;\n    }\n  }\n\n  // true if the layer has children\n  get hasChildren() {\n    return this.children.length > 0;\n  }\n\n  // add a child NestedLayer object\n  addChild(child) {\n    if (!(child instanceof NestedLayer)) {\n      throw new TypeError('child is not a NestedLayer');\n    }\n    this._props.children.push(child);\n  }\n\n  enableChildren() {\n    this._applyStateChangeToAllChildren('enabled', true, this.children);\n  }\n\n  disableChildren() {\n    this._applyStateChangeToAllChildren('enabled', false, this.children);\n  }\n\n  ownChildren() {\n    this._applyStateChangeToAllChildren('owner', this.owner, this.children);\n  }\n\n  _applyStateChangeToAllChildren(prop, val, children) {\n    // utility to recursively loop through children (and their children, etc.)\n    // to change their state\n    // IDEA: convert to a \"deep map\" function\n    for (let i = 0; i < children.length; i++) {\n      // make the state change\n      children[i][prop] = val;\n\n      // loop through children/subtrees when necessary\n      if (children[i].hasChildren) {\n        this._applyStateChangeToAllChildren(prop, val, children[i].children);\n      }\n    }\n  }\n\n  _handleMapZoom = () => {\n    const zoom = this.map.getZoom();\n\n    if (zoom < this.minZoom || zoom > this.maxZoom) {\n      this._detach();\n    } else {\n      this._attach()\n    }\n  }\n\n  // display on map\n  _attach() {\n    if (!this._isAttached) {\n      this.map.addLayer(this.layer);\n      // this.layer.addTo(this.map);\n      this._isAttached = true;\n    }\n  }\n\n  // remove from map\n  _detach() {\n    if (this._isAttached) {\n      this.map.removeLayer(this.layer);\n      // this.layer.removeFrom(this.map);\n      this._isAttached = false;\n    }\n  }\n}\n\n\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}