{"version":3,"sources":["Leaflet.NestedLayer.js"],"names":["NestedLayer","options","_handleMapZoom","zoom","map","getZoom","minZoom","maxZoom","_detach","_attach","_props","children","enabled","selected","swatch","_isAttached","id","Error","name","layer","Object","assign","select","undefined","on","child","TypeError","push","_setChildrenEnabledState","state","i","length","hasChildren","addTo","removeFrom","val","disabled","enableChildren","disableChildren"],"mappings":"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","file":"Leaflet.NestedLayer.js","sourcesContent":["import L from 'leaflet-headless';\n\nexport default class NestedLayer {\n\n  // options include:\n  // 'id' number (req'd), 'name' string (req'd), 'layer' object (req'd), 'map' object (req'd)\n  // 'enabled' boolean (optional), 'selected' boolean (optional), 'swatch' base64 string (optional)\n  // 'children' array (optional), 'minZoom' zoom level (optional), 'maxZoom' zoom level (optional)\n  constructor(options) {\n    // set default props for optional options\n    this._props = { children: [], enabled: true, selected: false, swatch: '' };\n    this._isAttached = false;\n\n    // verify that all required arguments are present\n    if (typeof options.id == 'undefined') {\n      throw new Error('Missing ID when creating NestedLayer');\n    }\n    if (typeof options.name == 'undefined') {\n      throw new Error('Missing name when creating NestedLayer');\n    }\n    if (typeof options.layer == 'undefined') {\n      throw new Error('Missing layer object when creating NestedLayer');\n    }\n    if (typeof options.map == 'undefined') {\n      throw new Error('Missing map object when creating NestedLayer');\n    }\n\n    Object.assign(this._props, options);\n\n    // if this layer is starting off selected, attach to the map\n    // calling this.select() ensures that we follow any other attachment rules\n    // built into the 'selected' setter\n    if (this.selected) {\n      this.select();\n    }\n\n    // if the zoom properties are on the leaflet layer object, copy them up to the\n    // NestedLayer object\n    if (this.layer.minZoom !== undefined && this.layer.maxZoom !== undefined) {\n      this._props.minZoom = this.layer.minZoom;\n      this._props.maxZoom = this.layer.maxZoom;\n    }\n\n    // if this layer has zoom data, we need to handle the case where the user zooms to a level where\n    // our layer should be disabled according to the minZoom/maxZoom contained in the layer object\n    if (this.minZoom !== undefined && this.maxZoom !== undefined) {\n      this.map.on('zoomend', this._handleMapZoom);\n    }\n  }\n\n  get id() {\n    return this._props.id;\n  }\n\n  get name() {\n    return this._props.name;\n  }\n\n  get layer() {\n    return this._props.layer;\n  }\n\n  get map() {\n    return this._props.map;\n  }\n\n  get swatch() {\n    return this._props.swatch;\n  }\n\n  get children() {\n    return this._props.children;\n  }\n\n  get minZoom() {\n    return this._props.minZoom;\n  }\n\n  get maxZoom() {\n    return this._props.maxZoom;\n  }\n\n  // enabled = user may freely toggle this layer on and off\n  // disabled = user may not toggle the layer\n  // disabling always deselects the layer, but the selected state is persisted, so that if\n  // the layer is re-enabled, the selected state is what it was prior to disabling\n  // i.e. if disabled, always deselected\n  // this logic is handled in the .selected getter\n  get enabled() {\n    return this._props.enabled;\n  }\n  set enabled(val) {\n    this._props.enabled = val;\n\n    // if disabling, detach from map\n    if (!val) {\n      this._detach();\n\n    // if enabling, and marked selected (i.e. \"re-enabling\"), attach to map\n    } else if (this._props.selected) {\n      this._attach();\n    }\n  }\n\n  // selected = layer present on the map\n  // deselected = layer not present on the map\n  get selected() {\n    if (this.disabled) {\n      return false;\n    } else {\n      return this._props.selected;\n    }\n  }\n  set selected(val) {\n    this._props.selected = val;\n\n    // attach/detach from map when needed\n    // disable children from selection when unselected\n    if (this.selected) {\n      this._attach();\n      this.enableChildren();\n    } else {\n      this._detach();\n      this.disableChildren();\n    }\n  }\n\n  // convenience methods to change state\n  enable() {\n    this.enabled = true;\n  }\n  disable() {\n    this.enabled = false;\n  }\n  toggleEnabled() {\n    this.enabled = !this.enabled;\n  }\n  select() {\n    this.selected = true;\n  }\n  deselect() {\n    this.selected = false;\n  }\n  toggleSelected() {\n    this.selected = !this.selected;\n  }\n\n  // convenience properties that reflect state\n  get disabled() {\n    return !this.enabled;\n  }\n  get deselected() {\n    return !this.selected;\n  }\n\n  // true if the layer has children\n  get hasChildren() {\n    return this.children.length > 0;\n  }\n\n  // add a child NestedLayer object\n  addChild(child) {\n    if (!(child instanceof NestedLayer)) {\n      throw new TypeError('child is not a NestedLayer');\n    }\n    this._props.children.push(child);\n  }\n\n  enableChildren() {\n    this._setChildrenEnabledState(true, this.children);\n  }\n\n  disableChildren() {\n    this._setChildrenEnabledState(false, this.children);\n  }\n\n  _setChildrenEnabledState(state, children) {\n    // recursively loops through children (and their children, etc.) to\n    // either enable or disable\n    for (let i = 0; i < children.length; i++) {\n      children[i].enabled = state;\n      if (children[i].hasChildren) {\n        this._setChildrenEnabledState(state, children[i].children);\n      }\n    }\n  }\n\n  _handleMapZoom = () => {\n    const zoom = this.map.getZoom();\n\n    if (zoom < this.minZoom || zoom > this.maxZoom) {\n      this._detach();\n    } else {\n      this._attach()\n    }\n  }\n\n  // display on map\n  _attach() {\n    if (!this._isAttached) {\n      this.layer.addTo(this.map);\n      this._isAttached = true;\n    }\n  }\n\n  // remove from map\n  _detach() {\n    if (this._isAttached) {\n      this.layer.removeFrom(this.map);\n      this._isAttached = false;\n    }\n  }\n}\n\n\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}