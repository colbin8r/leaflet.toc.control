{"version":3,"sources":["Leaflet.TOC.NestedLayer.js"],"names":["generateID","NestedLayerTreeHelper","lastID","Number","parseInt","Math","floor","random","toString","NestedLayer","constructor","_defaults","layerID","name","layer","map","props","Error","_props","defaults","id","_isAttached","selected","select","minZoom","undefined","maxZoom","enabled","child","TypeError","children","push","hasLayer","addLayer","removeLayer","parent","rules","val","_detach","enableTriggersAttach","_attach","alwaysDeselectedWhenDisabled","disabled","disableDescendentsWhenDeselected","applyStateChangeToTree","length","NEGATIVE_INFINITY","POSITIVE_INFINITY"],"mappings":"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","file":"Leaflet.TOC.NestedLayer.js","sourcesContent":["import { defaultsDeep as defaults } from 'lodash';\nimport * as NestedLayerTreeHelper from './Leaflet.TOC.NestedLayerTreeHelper';\n\nlet lastID = 0;\n\n/**\n * Generate a ID number guaranteed to be unique.\n * IDs are composed of a pseudorandom 4-digit number suffixed by an incrementing counter.\n * @return {Number} Unique ID number\n */\nexport function generateID() {\n  // generates a 4 digit random number\n  // lastID is appended to the end of the number\n  // lastID is incremented each\n  return Number.parseInt(Math.floor(1000 + Math.random() * 9000).toString()\n                         + (lastID++).toString());\n}\n\n/**\n * Wraps a Leaflet Layer to allow that layer to be the \"parent\" of other layers by having\n * \"child\" layers\n * @see http://leafletjs.com/reference-1.1.0.html#layer\n */\nexport default class NestedLayer {\n\n  static _defaults = {\n    parent: null,\n    children: [],\n    enabled: true,\n    selected: false,\n    minZoom: Number.NEGATIVE_INFINITY,\n    maxZoom: Number.POSITIVE_INFINITY,\n    rules: {\n      enableTriggersAttach: true,\n      alwaysDeselectedWhenDisabled: true,\n      disableDescendentsWhenDeselected: true\n    }\n  }\n\n  get defaults() {\n    // uses reflection to return the static _defaults property on the class\n    return this.constructor._defaults;\n  }\n\n  /**\n   *\n   * @param {object} props The layer data\n   * @param {number} props.id The layer's unique ID number\n   * @param {string} props.name The layer's unique name\n   * @param {L.Layer} props.layer A {@link\n   * http://leafletjs.com/reference-1.1.0.html#layer Leaflet layer}\n   * @param {L.Map} props.map {@link\n   * http://leafletjs.com/reference-1.1.0.html#map Leaflet map} to attach to\n   * @param {boolean} [props.enabled=true] Initial enabled state of the layer\n   * @param {boolean} [props.selected=false] Initial selected state of the layer\n   * @param {string} [props.swatch=''] Base64 encoded swatch PNG\n   * @param {NestedLayer[]} [props.children=[]] Child layers\n   * @param {number} [props.minZoom] Minimum zoom level that the layer should be visible\n   * @param {number} [props.maxZoom] Maximum zoom level that the layer should be visible\n   */\n\n  /**\n   * Creates a new NestedLayer.\n   * @param  {number} layerID ID of the layer on the origin.\n   * @param  {string} name    Name of the layer on the origin; display-friendly\n   * @param  {L.Layer} layer   Leaflet layer\n   * @param  {L.Map} map     Leaflet map\n   * @param  {object} props   Optional properties\n   */\n  constructor(layerID, name, layer, map, props) {\n\n    // ensure all required props are present\n    if (typeof layerID == 'undefined') {\n      throw new Error('Missing layer ID when creating NestedLayer');\n    }\n    if (typeof name == 'undefined') {\n      throw new Error('Missing name when creating NestedLayer');\n    }\n    if (typeof layer == 'undefined') {\n      throw new Error('Missing layer object when creating NestedLayer');\n    }\n    if (typeof map == 'undefined') {\n      throw new Error('Missing map object when creating NestedLayer');\n    }\n\n    // set the required props\n    this._props = {\n      layerID,\n      name,\n      layer,\n      map\n    };\n\n    // merge optional props with defaults\n    // the \"defaults\" also contains the initial state\n    defaults(this._props, props, this.defaults);\n    this._props.id = generateID();\n    this._isAttached = false;\n\n    // if this layer is starting off selected, attach to the map\n    // calling this.select() ensures that we follow any other attachment rules\n    // built into the 'selected' setter\n    if (this.selected) {\n      this.select();\n    }\n\n    // if the zoom properties are on the leaflet layer object, copy them up to the\n    // NestedLayer object\n    if (this.layer.minZoom !== undefined && this.layer.maxZoom !== undefined) {\n      this._props.minZoom = this.layer.minZoom;\n      this._props.maxZoom = this.layer.maxZoom;\n    }\n\n    // if this layer has zoom data, we need to handle the case where the user zooms to a level where\n    // our layer should be disabled according to the minZoom/maxZoom contained in the layer object\n    // if (this.minZoom !== undefined && this.maxZoom !== undefined) {\n    //   this.map.on('zoomend', this._handleMapZoom);\n    // }\n  }\n\n  /**\n   * Layer ID as specified by the server\n   * @type {number}\n   */\n  get layerID() {\n    return this._props.layerID;\n  }\n\n  /**\n   * Layer name\n   * @type {string}\n   */\n  get name() {\n    return this._props.name;\n  }\n\n  /**\n   * Underlying Leaflet layer\n   * @type {L.Layer}\n   */\n  get layer() {\n    return this._props.layer;\n  }\n\n  /**\n   * Leaflet Map to attach to\n   * @type {L.Map}\n   */\n  get map() {\n    return this._props.map;\n  }\n\n  /**\n   * Child layers\n   * @type {NestedLayer[]}\n   */\n  get children() {\n    return this._props.children;\n  }\n\n  /**\n   * Parent layer\n   * @type {NestedLayer}\n   */\n  get parent() {\n    return this._props.parent;\n  }\n\n  /**\n   * Minimum zoom level for this layer to be visible\n   * @type {number}\n   */\n  get minZoom() {\n    return this._props.minZoom;\n  }\n\n  /**\n   * Maximum zoom level for this layer to be visible\n   * @type {number}\n   */\n  get maxZoom() {\n    return this._props.maxZoom;\n  }\n\n  get rules() {\n    return this._props.rules;\n  }\n\n  /**\n   * Unique ID generated for each NestedLayer\n   * @type {number}\n   */\n  get id() {\n    return this._props.id;\n  }\n\n  // enabled = user may freely toggle this layer on and off\n  // disabled = user may not toggle the layer\n  // disabling always deselects the layer, but the selected state is persisted, so that if\n  // the layer is re-enabled, the selected state is what it was prior to disabling\n  // i.e. if disabled, always deselected\n  // this logic is handled in the .selected getter\n\n  /**\n   * Whether the user may freely toggle this layer on and off\n   * @type {boolean}\n   */\n  get enabled() {\n    return this._props.enabled;\n  }\n  set enabled(val) {\n    this._props.enabled = val;\n\n    // if disabling, detach from map\n    if (!val) {\n      this._detach();\n\n    // if enabling, and marked selected (i.e. \"re-enabling\"), attach to map\n    } else if (this.rules.enableTriggersAttach && this._props.selected) {\n      this._attach();\n    }\n  }\n  /**\n   * The inverse of #enabled\n   * @type {boolean}\n   */\n  get disabled() {\n    return !this.enabled;\n  }\n\n  /** Enable the layer */\n  enable() {\n    this.enabled = true;\n  }\n  /** Disable the layer */\n  disable() {\n    this.enabled = false;\n  }\n  /** Toggle the layer's enabled state */\n  toggleEnabled() {\n    this.enabled = !this.enabled;\n  }\n\n  // selected = layer present on the map\n  // deselected = layer not present on the map\n  get selected() {\n    if (this.rules.alwaysDeselectedWhenDisabled && this.disabled) {\n      return false;\n    } else {\n      return this._props.selected;\n    }\n  }\n  set selected(val) {\n    this._props.selected = val;\n\n    // attach/detach from map when needed\n    // disable children from selection when unselected\n    if (this.selected) {\n      this._attach();\n      // this.enableChildren();\n    } else {\n      this._detach();\n      // this.disableChildren();\n    }\n\n    // if configured to, disable all descendents if deselected\n    if (this.rules.disableDescendentsWhenDeselected) {\n      NestedLayerTreeHelper.applyStateChangeToTree(this.children, { enabled: this.selected });\n    }\n  }\n  get deselected() {\n    return !this.selected;\n  }\n  select() {\n    this.selected = true;\n  }\n  deselect() {\n    this.selected = false;\n  }\n  toggleSelected() {\n    this.selected = !this.selected;\n  }\n\n  // true if the layer has children\n  get hasChildren() {\n    return this.children.length > 0;\n  }\n\n  // add a child NestedLayer object\n  addChild(child) {\n    if (!(child instanceof NestedLayer)) {\n      throw new TypeError('child is not a NestedLayer');\n    }\n    this._props.children.push(child);\n  }\n\n  // _handleMapZoom = () => {\n  //   const zoom = this.map.getZoom();\n\n  //   if (zoom < this.minZoom || zoom > this.maxZoom) {\n  //     this._detach();\n  //   } else {\n  //     this._attach()\n  //   }\n  // }\n\n  // display on map\n  _attach() {\n    if (!this._isAttached && !this.map.hasLayer(this.layer)) {\n      this.map.addLayer(this.layer);\n      // this.layer.addTo(this.map);\n    }\n    this._isAttached = true;\n  }\n\n  // remove from map\n  _detach() {\n    if (this._isAttached && this.map.hasLayer(this.layer)) {\n      this.map.removeLayer(this.layer);\n      // this.layer.removeFrom(this.map);\n    }\n    this._isAttached = false;\n  }\n}\n\n\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}