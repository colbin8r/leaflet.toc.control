{"version":3,"sources":["Leaflet.TOC.NestedLayer.js"],"names":["generateID","NestedLayerTreeHelper","lastID","Number","parseInt","Math","floor","random","toString","NestedLayer","constructor","_defaults","layerID","name","layer","map","props","Error","_props","symbology","defaults","id","selected","select","enabled","child","TypeError","parent","children","push","minZoom","maxZoom","currentZoomLevel","getZoom","aboveMinZoom","belowMaxZoom","withinZoomRange","isAttached","hasLayer","addLayer","removeLayer","val","rules","_detach","enableTriggersAttach","_attach","alwaysDeselectedWhenDisabled","disabled","disableDescendentsWhenDeselected","applyStateChangeToTree","_withinZoomRange","length","NEGATIVE_INFINITY","POSITIVE_INFINITY"],"mappings":"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","file":"Leaflet.TOC.NestedLayer.js","sourcesContent":["import { defaultsDeep as defaults } from 'lodash';\n\nimport * as NestedLayerTreeHelper from './Leaflet.TOC.NestedLayerTreeHelper';\nimport MapSymbology from './Leaflet.TOC.MapSymbology';\n\nlet lastID = 0;\n\n/**\n * Generate a ID number guaranteed to be unique.\n * IDs are composed of a pseudorandom 4-digit number suffixed by an incrementing counter.\n * @return {Number} Unique ID number\n */\nexport function generateID() {\n  // generates a 4 digit random number\n  // lastID is appended to the end of the number\n  // lastID is incremented each\n  return Number.parseInt(Math.floor(1000 + Math.random() * 9000).toString()\n                         + (lastID++).toString());\n}\n\n/**\n * Wraps a Leaflet Layer to allow that layer to be the \"parent\" of other layers by having\n * \"child\" layers\n * @see http://leafletjs.com/reference-1.1.0.html#layer\n */\nexport default class NestedLayer {\n\n  static _defaults = {\n    parent: null,\n    children: [],\n    enabled: true,\n    selected: false,\n    minZoom: Number.NEGATIVE_INFINITY,\n    maxZoom: Number.POSITIVE_INFINITY,\n    rules: {\n      enableTriggersAttach: true,\n      alwaysDeselectedWhenDisabled: true,\n      disableDescendentsWhenDeselected: true\n    }\n  }\n\n  get defaults() {\n    // uses reflection to return the static _defaults property on the class\n    return this.constructor._defaults;\n  }\n\n  /**\n   *\n   * @param {object} props The layer data\n   * @param {number} props.id The layer's unique ID number\n   * @param {string} props.name The layer's unique name\n   * @param {L.Layer} props.layer A {@link\n   * http://leafletjs.com/reference-1.1.0.html#layer Leaflet layer}\n   * @param {L.Map} props.map {@link\n   * http://leafletjs.com/reference-1.1.0.html#map Leaflet map} to attach to\n   * @param {boolean} [props.enabled=true] Initial enabled state of the layer\n   * @param {boolean} [props.selected=false] Initial selected state of the layer\n   * @param {string} [props.swatch=''] Base64 encoded swatch PNG\n   * @param {NestedLayer[]} [props.children=[]] Child layers\n   * @param {number} [props.minZoom] Minimum zoom level that the layer should be visible\n   * @param {number} [props.maxZoom] Maximum zoom level that the layer should be visible\n   */\n\n  /**\n   * Creates a new NestedLayer.\n   * @param  {number} layerID ID of the layer on the origin.\n   * @param  {string} name    Name of the layer on the origin; display-friendly\n   * @param  {L.Layer} layer   Leaflet layer\n   * @param  {L.Map} map     Leaflet map\n   * @param  {object} props   Optional properties\n   */\n  constructor(layerID, name, layer, map, props) {\n\n    // ensure all required props are present\n    if (typeof layerID == 'undefined') {\n      throw new Error('Missing layer ID when creating NestedLayer');\n    }\n    if (typeof name == 'undefined') {\n      throw new Error('Missing name when creating NestedLayer');\n    }\n    if (typeof layer == 'undefined') {\n      throw new Error('Missing layer object when creating NestedLayer');\n    }\n    if (typeof map == 'undefined') {\n      throw new Error('Missing map object when creating NestedLayer');\n    }\n\n    // set the required props\n    this._props = {\n      layerID,\n      name,\n      layer,\n      map\n    };\n\n    // this prop isn't set on defaults\n    // if it is, then all instances that use the default will share the same instance\n    // (NOT what you want)\n    this._props.symbology = new MapSymbology()\n\n    // merge optional props with defaults\n    // the \"defaults\" also contains the initial state\n    defaults(this._props, props, this.defaults);\n    this._props.id = generateID();\n\n    // if this layer is starting off selected, attach to the map\n    // calling this.select() ensures that we follow any other attachment rules\n    // built into the 'selected' setter\n    if (this._props.selected) {\n      this.select();\n    }\n\n    // if the zoom properties are on the leaflet layer object, copy them up to the\n    // NestedLayer object\n    // if (this.layer.minZoom !== undefined && this.layer.maxZoom !== undefined) {\n    //   this._props.minZoom = this.layer.minZoom;\n    //   this._props.maxZoom = this.layer.maxZoom;\n    // }\n\n    // if this layer has zoom data, we need to handle the case where the user zooms to a level where\n    // our layer should be disabled according to the minZoom/maxZoom contained in the layer object\n    // if (this.minZoom !== undefined && this.maxZoom !== undefined) {\n    //   this.map.on('zoomend', this._handleMapZoom);\n    // }\n  }\n\n  /**\n   * Layer ID as specified by the server\n   * @type {number}\n   */\n  get layerID() {\n    return this._props.layerID;\n  }\n\n  /**\n   * Layer name\n   * @type {string}\n   */\n  get name() {\n    return this._props.name;\n  }\n\n  /**\n   * Underlying Leaflet layer\n   * @type {L.Layer}\n   */\n  get layer() {\n    return this._props.layer;\n  }\n\n  /**\n   * Leaflet Map to attach to\n   * @type {L.Map}\n   */\n  get map() {\n    return this._props.map;\n  }\n\n  /**\n   * Child layers\n   * @type {NestedLayer[]}\n   */\n  get children() {\n    return this._props.children;\n  }\n\n  /**\n   * Parent layer\n   * @type {NestedLayer}\n   */\n  get parent() {\n    return this._props.parent;\n  }\n  set parent(val) {\n    this._props.parent = val;\n  }\n\n  /**\n   * Map symbology\n   * @type {MapSymbology}\n   */\n  get symbology() {\n    return this._props.symbology;\n  }\n\n  /**\n   * Minimum zoom level for this layer to be visible\n   * @type {number}\n   */\n  get minZoom() {\n    return this._props.minZoom;\n  }\n  set minZoom(val) {\n    this._props.minZoom = val;\n  }\n\n  /**\n   * Maximum zoom level for this layer to be visible\n   * @type {number}\n   */\n  get maxZoom() {\n    return this._props.maxZoom;\n  }\n  set maxZoom(val) {\n    this._props.maxZoom = val;\n  }\n\n  get rules() {\n    return this._props.rules;\n  }\n\n  /**\n   * Unique ID generated for each NestedLayer\n   * @type {number}\n   */\n  get id() {\n    return this._props.id;\n  }\n\n  // enabled = user may freely toggle this layer on and off\n  // disabled = user may not toggle the layer\n  // disabling always deselects the layer, but the selected state is persisted, so that if\n  // the layer is re-enabled, the selected state is what it was prior to disabling\n  // i.e. if disabled, always deselected\n  // this logic is handled in the .selected getter\n\n  /**\n   * Whether the user may freely toggle this layer on and off\n   * @type {boolean}\n   */\n  get enabled() {\n    return this._props.enabled;\n  }\n  set enabled(val) {\n    this._props.enabled = val;\n\n    // if disabling, detach from map\n    if (!val) {\n      this._detach();\n\n    // if enabling, and marked selected (i.e. \"re-enabling\"), attach to map\n    } else if (this.rules.enableTriggersAttach && this._props.selected) {\n      this._attach();\n    }\n  }\n  /**\n   * The inverse of #enabled\n   * @type {boolean}\n   */\n  get disabled() {\n    return !this.enabled;\n  }\n\n  /** Enable the layer */\n  enable() {\n    this.enabled = true;\n  }\n  /** Disable the layer */\n  disable() {\n    this.enabled = false;\n  }\n  /** Toggle the layer's enabled state */\n  toggleEnabled() {\n    this.enabled = !this.enabled;\n  }\n\n  // selected = layer present on the map\n  // deselected = layer not present on the map\n  get selected() {\n    if (this.rules.alwaysDeselectedWhenDisabled && this.disabled) {\n      return false;\n    } else {\n      return this._props.selected;\n    }\n  }\n  set selected(val) {\n    this._props.selected = val;\n\n    // attach/detach from map when needed\n    // disable children from selection when unselected\n    if (this.selected) {\n      this._attach();\n      // this.enableChildren();\n    } else {\n      this._detach();\n      // this.disableChildren();\n    }\n\n    // if configured to, disable all descendents if deselected\n    if (this.rules.disableDescendentsWhenDeselected) {\n      NestedLayerTreeHelper.applyStateChangeToTree(this.children, { enabled: this.selected });\n    }\n  }\n  get deselected() {\n    return !this.selected;\n  }\n  select() {\n    this.selected = true;\n  }\n  deselect() {\n    this.selected = false;\n  }\n  toggleSelected() {\n    this.selected = !this.selected;\n  }\n\n  /**\n   * Checks if the layer could be visible on the map\n   * @type {boolean}\n   */\n  get visible() {\n    return this.selected && this._withinZoomRange();\n  }\n\n  /**\n   * Checks if is bound to the Leaflet map\n   * @type {boolean}\n   */\n  get isAttached() {\n    return this.map.hasLayer(this.layer);\n  }\n\n  // true if the layer has children\n  get hasChildren() {\n    return this.children.length > 0;\n  }\n\n  // add a child NestedLayer object\n  addChild(child) {\n    if (!(child instanceof NestedLayer)) {\n      throw new TypeError('child is not a NestedLayer');\n    }\n    child.parent = this;\n    this._props.children.push(child);\n  }\n\n  // returns true if the layer could be visible at the current zoom level at the map\n  _withinZoomRange() {\n    // if no range specifies, assume that it is always valid\n    if (!this.minZoom || !this.maxZoom) {\n      return true;\n    }\n    // check if the layer is visible at the current zoom level\n    const currentZoomLevel = map.getZoom();\n    const aboveMinZoom = currentZoomLevel >= this.minZoom;\n    const belowMaxZoom = currentZoomLevel <= this.maxZoom\n    const withinZoomRange = aboveMinZoom && belowMaxZoom;\n    // console.log('within zoom range?', withinZoomRange,\n                // 'min:', this.minZoom, '<=', currentZoomLevel, aboveMinZoom,\n                // 'max:', this.maxZoom, '>=', currentZoomLevel, belowMaxZoom);\n    return (currentZoomLevel >= this.minZoom && currentZoomLevel <= this.maxZoom);\n  }\n\n  // display on map\n  _attach() {\n    if (!this.isAttached && !this.map.hasLayer(this.layer)) {\n      this.map.addLayer(this.layer);\n      // this.layer.addTo(this.map);\n    }\n  }\n\n  // remove from map\n  _detach() {\n    if (this.isAttached && this.map.hasLayer(this.layer)) {\n      this.map.removeLayer(this.layer);\n      // this.layer.removeFrom(this.map);\n    }\n  }\n\n}\n\n\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}