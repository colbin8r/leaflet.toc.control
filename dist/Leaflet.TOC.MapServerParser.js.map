{"version":3,"sources":["Leaflet.TOC.MapServerParser.js"],"names":["NestedLayerTreeHelper","request","MapServerParser","url","map","options","Error","_url","_map","_options","defaults","layerOptions","dynamicMapLayerOptions","_layer","join","_queryLayers","_queryLegend","layerResponse","legendResponse","ok","layers","_parseBodyAsJSON","legend","tree","forEach","node","layer","_parseNode","parsingOptions","defaultVisibility","selected","symbology","legendEntry","find","legendNode","layerId","layerID","length","entry","addSymbol","scale","leafletMostZoomedInLevel","leafletLeastZoomedInLevel","max","maxScale","crs","zoom","Number","POSITIVE_INFINITY","min","minScale","NEGATIVE_INFINITY","console","log","minZoom","maxZoom","parentLayer","parentID","id","parent","getLayerByLayerID","addChild","push","validateTreeEnabledState","layerdataURL","constructor","APIEndpoints","get","set","Headers","query","QueryParameters","end","legendURL","response","body","type","Accept","JSON","parse","text","layerType","name","layerProps","_defaults","f"],"mappings":"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","file":"Leaflet.TOC.MapServerParser.js","sourcesContent":["import { defaultsDeep as defaults } from 'lodash';\n// superagent mimics the node 'request' library on the client side as an xhr library\nimport superagent from 'superagent';\nimport Promise from 'bluebird';\nimport superagentPromise from 'superagent-promise';\nconst request = superagentPromise(superagent, Promise);\n\nimport NestedDynamicMapLayer from './Leaflet.TOC.NestedDynamicMapLayer';\nimport NestedGroupLayer from './Leaflet.TOC.NestedGroupLayer';\nimport * as NestedLayerTreeHelper from './Leaflet.TOC.NestedLayerTreeHelper';\nimport MapSymbol from './Leaflet.TOC.MapSymbol';\nimport { DynamicMapLayer } from 'esri-leaflet';\n\nexport default class MapServerParser {\n\n  static _defaults = {\n    parsingOptions: {\n      scale: true,\n      defaultVisibility: true,\n      symbology: false\n    },\n    layerProps: {},\n    dynamicMapLayerOptions: {}\n  };\n\n  static APIEndpoints = {\n    layers: '/layers',\n    legend: '/legend'\n  };\n\n  static QueryParameters = {\n    f: 'json'\n  };\n\n  static Headers = {\n    Accept: 'application/json'\n  };\n\n  constructor(url, map, options) {\n    // ensure required parameters are present\n    if (typeof url == 'undefined') {\n      throw new Error('Missing URL when creating MapServerParser');\n    }\n    if (typeof map == 'undefined') {\n      throw new Error('Missing Leaflet map object when creating MapServerParser');\n    }\n\n    // save url\n    this._url = url;\n\n    // save map\n    this._map = map;\n\n    // https://lodash.com/docs/4.17.4#defaultsDeep\n    this._options = defaults({}, options, this.defaults);\n\n    // create a new DynamicMapLayer to use in all of our NestedDynamicMapLayers\n    let layerOptions = defaults({ url }, this.options.dynamicMapLayerOptions)\n    this._layer = new DynamicMapLayer(layerOptions);\n  }\n\n  /**\n   * MapServer URL\n   * @type {string}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Leaflet Map object\n   * @type {L.Map}\n   */\n  get map() {\n    return this._map;\n  }\n\n  /**\n   * Configuration options\n   * @type {object}\n   */\n  get options() {\n    return this._options;\n  }\n\n  /**\n   * Default configuration options\n   * @type {object}\n   */\n  get defaults() {\n    // uses reflection to return the static _defaults property on the class\n    return this.constructor._defaults;\n  }\n\n  /**\n   * Esri-Leaflet DynamicMapLayer object\n   * @type {DynamicMapLayer}\n   */\n  get layer() {\n    return this._layer;\n  }\n\n  parse() {\n    // we have to wait for both xhr promises to resolve before we can begin processing\n    // note that Promise.join returns a promise that resolves to a LayerHierarchy\n    return Promise.join(this._queryLayers(), this._queryLegend(), (layerResponse, legendResponse) => {\n      // ensure we hit HTTP 2xx statuses\n      if (!layerResponse.ok || !legendResponse.ok) {\n        throw new Error('Bad request: HTTP status was not 2xx');\n      }\n\n      // parse the layer data into JSON\n      let layers = this._parseBodyAsJSON(layerResponse);\n\n      // parse the legend data into JSON\n      let legend = this._parseBodyAsJSON(legendResponse);\n\n      // restrict ourselves to the 'layers' node of the response bodies\n      layers = layers.layers;\n      legend = legend.layers;\n\n      let tree = [];\n\n      layers.forEach((node) => {\n        let layer = this._parseNode(node);\n\n        if (this.options.parsingOptions.defaultVisibility) {\n          layer.selected = node.defaultVisibility;\n        }\n\n        if (this.options.parsingOptions.symbology) {\n\n          // find the entry in the legend corresponding to the current layer\n          let legendEntry = legend.find((legendNode) => {\n            return legendNode.layerId == layer.layerID;\n          })\n\n          // confirm that there is symbology for the layer\n          if (legendEntry && legendEntry.legend && legendEntry.legend.length > 0) {\n\n            // add each entry from the legend node in the entry as a MapSymbol\n            legendEntry.legend.forEach((entry) => {\n              layer.symbology.addSymbol(new MapSymbol(entry));\n            })\n\n          }\n        }\n\n        if (this.options.parsingOptions.scale) {\n          // convert the 'scale' data returned by ArcGIS to 'zoom' data used by Leaflet\n          // if ArcGIS returns '0', set to Inifinity or -Infinity where appropriate\n          // http://leafletjs.com/reference-1.2.0.html#crs-zoom\n          // https://github.com/Leaflet/Leaflet/blob/master/src/map/Map.js#L39\n          const leafletMostZoomedInLevel = 19;\n          const leafletLeastZoomedInLevel = 1;\n          const max = (node.maxScale !== 0 ? leafletLeastZoomedInLevel + this.map.options.crs.zoom(node.maxScale) : Number.POSITIVE_INFINITY);\n          const min = (node.minScale !== 0 ? leafletMostZoomedInLevel - this.map.options.crs.zoom(node.minScale) : Number.NEGATIVE_INFINITY);\n          console.log('MapServerParser min', min, 'max', max);\n          // console.log('nodemax', node.maxScale, 'min', min, 'nodemin', node.minScale, 'max', max);\n          layer.minZoom = min;\n          layer.maxZoom = max;\n        }\n\n        // add the layer into the proper subtree\n        if (node.parentLayer !== null) {\n          let parentID = node.parentLayer.id;\n          // this assumes that the parent has already been parsed\n          let parent = NestedLayerTreeHelper.getLayerByLayerID(tree, parentID);\n          parent.addChild(layer);\n        } else {\n          tree.push(layer);\n        }\n      })\n\n      NestedLayerTreeHelper.validateTreeEnabledState(tree);\n\n      return tree;\n    });\n  }\n\n  _queryLayers() {\n    // assemble layerdata url\n    const layerdataURL = this.url + this.constructor.APIEndpoints.layers;\n\n    // fetch layerdata as JSON\n    return request\n      .get(layerdataURL)\n      .set(this.constructor.Headers)\n      .query(this.constructor.QueryParameters)\n      .end();\n  }\n\n  _queryLegend() {\n    // assemble legend url\n    const legendURL = this.url + this.constructor.APIEndpoints.legend;\n\n    // fetch legend as JSON\n    return request\n      .get(legendURL)\n      .set(this.constructor.Headers)\n      .query(this.constructor.QueryParameters)\n      .end();\n  }\n\n  _parseBodyAsJSON(response) {\n    // parse the data into JSON\n    let body = response.body;\n    // ArcGIS does not properly set its Content-Type header\n    // so force JSON parsing if superagent did not parse automatically\n    if (response.type !== this.constructor.Headers.Accept) {\n      body = JSON.parse(response.text);\n    }\n\n    return body;\n  }\n\n  _parseNode(node) {\n    let layerType;\n\n    switch (node.type) {\n      case 'Group Layer':\n        layerType = NestedGroupLayer;\n        break;\n      case 'Feature Layer':\n        layerType = NestedDynamicMapLayer\n        break;\n      default:\n        throw 'Invalid layer type: ' + node.type;\n    }\n\n    return new layerType(\n      node.id,\n      node.name,\n      this.layer,\n      this.map,\n      this.options.layerProps);\n  }\n\n}\n"],"sourceRoot":"/mnt/c/dev/Leaflet.Control.NestedLayers/src"}